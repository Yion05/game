<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPS Drawing Battle</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .game-container {
            background-color: #2d3748; /* Slightly lighter dark background */
            border-radius: 1.5rem; /* More rounded corners */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4); /* Stronger shadow */
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 25px;
            max-width: 1200px;
            width: 100%;
        }
        .player-section {
            background-color: #4a5568; /* Even lighter dark background for sections */
            border-radius: 1rem;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        canvas {
            border: 2px solid #63b3ed; /* Blue border for canvas */
            background-color: #ffffff; /* White drawing area */
            border-radius: 0.75rem;
            cursor: crosshair;
            touch-action: none; /* Prevent default touch actions like scrolling/zooming */
        }
        .health-bar-container {
            width: 100%;
            background-color: #e53e3e; /* Red for health bar background */
            border-radius: 0.5rem;
            height: 25px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .health-bar {
            height: 100%;
            background-color: #48bb78; /* Green for health */
            border-radius: 0.5rem;
            transition: width 0.5s ease-in-out;
        }
        .btn {
            padding: 12px 20px;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            border: none;
            outline: none;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
        }
        .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .btn-primary {
            background-color: #63b3ed; /* Blue */
            color: #1a202c;
        }
        .btn-primary:hover {
            background-color: #4299e1;
        }
        .btn-success {
            background-color: #48bb78; /* Green */
            color: #1a202c;
        }
        .btn-success:hover {
            background-color: #38a169;
        }
        .btn-danger {
            background-color: #e53e3e; /* Red */
            color: #1a202c;
        }
        .btn-danger:hover {
            background-color: #c53030;
        }
        .btn-warning {
            background-color: #ecc94b; /* Yellow */
            color: #1a202c;
        }
        .btn-warning:hover {
            background-color: #d69e2e;
        }
        .btn-disabled {
            background-color: #a0aec0; /* Gray */
            color: #4a5568;
            cursor: not-allowed;
            box-shadow: none;
        }
        .btn-disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .message-box {
            background-color: #2c5282; /* Darker blue for messages */
            border-radius: 0.75rem;
            padding: 15px;
            text-align: center;
            font-size: 1.1rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .weapon-item {
            background-color: #63b3ed;
            color: #1a202c;
            padding: 8px 12px;
            border-radius: 0.5rem;
            font-size: 0.9rem;
            font-weight: 500;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .weapon-item.owned {
            background-color: #48bb78;
        }

        /* Responsive adjustments */
        @media (min-width: 768px) {
            .game-container {
                flex-direction: row;
                justify-content: space-around;
                align-items: flex-start;
            }
            .player-section {
                width: 48%; /* Adjust width for two columns */
            }
        }
        @media (max-width: 767px) {
            .game-container {
                flex-direction: column;
            }
            .player-section {
                width: 100%;
            }
        }

        /* Modal styles */
        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        .modal-content {
            background-color: #2d3748;
            padding: 30px;
            border-radius: 1.5rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            max-width: 500px;
            width: 90%;
            text-align: center;
            position: relative;
            animation: fadeIn 0.3s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .modal-close-btn {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 1.8rem;
            cursor: pointer;
            color: #e2e8f0;
        }
        .modal-close-btn:hover {
            color: #cbd5e0;
        }
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 25px;
        }
        .lobby-section {
            background-color: #2d3748;
            border-radius: 1.5rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 600px;
            width: 100%;
            text-align: center;
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #63b3ed;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex items-center justify-center min-h-screen p-5">

    <!-- Lobby Section -->
    <div id="lobbySection" class="lobby-section">
        <h2 class="text-3xl font-bold text-center text-blue-300">RPS Drawing Battle</h2>
        <p class="text-lg text-center">Your User ID: <span id="currentUserId" class="font-bold text-yellow-300">Loading...</span></p>

        <div class="flex flex-col gap-4">
            <input type="text" id="gameIdInput" placeholder="Enter Game ID to Join"
                   class="p-3 rounded-lg bg-gray-700 text-gray-100 border border-gray-600 focus:outline-none focus:border-blue-400">
            <button id="joinGameBtn" class="btn btn-primary">Join Game</button>
            <div class="text-center text-lg">OR</div>
            <button id="createGameBtn" class="btn btn-success">Create New Game</button>
        </div>
        <div id="lobbyMessage" class="text-red-400 text-sm mt-2"></div>
    </div>

    <!-- Game Container (hidden initially) -->
    <div id="gameContainer" class="game-container hidden">
        <!-- Player 1 Section -->
        <div id="player1Section" class="player-section">
            <h2 class="text-2xl font-bold text-center text-blue-300">Player 1 (<span id="player1Status">Waiting...</span>)</h2>
            <div class="health-bar-container">
                <div id="player1HealthBar" class="health-bar" style="width: 100%;"></div>
            </div>
            <p class="text-lg text-center">Health: <span id="player1Health">10</span></p>
            <p class="text-lg text-center">Wins: <span id="player1Wins">0</span></p>
            <p class="text-lg text-center">Defense: <span id="player1Defense">0</span></p>

            <h3 class="text-xl font-semibold mt-4 text-center">Draw Your Character:</h3>
            <canvas id="player1Canvas" width="300" height="300" class="mx-auto"></canvas>
            <button id="player1ClearBtn" class="btn btn-danger mt-2">Clear Drawing</button>

            <h3 class="text-xl font-semibold mt-4 text-center">Rock Paper Scissors:</h3>
            <div class="flex justify-center gap-3 mt-2">
                <button id="player1RockBtn" class="btn btn-primary rps-btn" data-player="1" data-choice="rock">Rock</button>
                <button id="player1PaperBtn" class="btn btn-primary rps-btn" data-player="1" data-choice="paper">Paper</button>
                <button id="player1ScissorsBtn" class="btn btn-primary rps-btn" data-player="1" data-choice="scissors">Scissors</button>
            </div>

            <h3 class="text-xl font-semibold mt-4 text-center">Actions:</h3>
            <div class="flex flex-col gap-3 mt-2">
                <button id="player1DefendBtn" class="btn btn-success action-btn" data-player="1">Defend (+2 Defense)</button>
                <button id="player1AttackBtn" class="btn btn-warning action-btn" data-player="1">Attack Opponent</button>
                <button id="player1BuyWeaponBtn" class="btn btn-primary action-btn" data-player="1">Buy Weapon</button>
            </div>

            <h3 class="text-xl font-semibold mt-4 text-center">Your Weapons:</h3>
            <ul id="player1WeaponsList" class="flex flex-col gap-2 mt-2">
                <!-- Weapons will be dynamically added here -->
            </ul>
        </div>

        <!-- Player 2 Section -->
        <div id="player2Section" class="player-section">
            <h2 class="text-2xl font-bold text-center text-blue-300">Player 2 (<span id="player2Status">Waiting...</span>)</h2>
            <div class="health-bar-container">
                <div id="player2HealthBar" class="health-bar" style="width: 100%;"></div>
            </div>
            <p class="text-lg text-center">Health: <span id="player2Health">10</span></p>
            <p class="text-lg text-center">Wins: <span id="player2Wins">0</span></p>
            <p class="text-lg text-center">Defense: <span id="player2Defense">0</span></p>

            <h3 class="text-xl font-semibold mt-4 text-center">Draw Your Character:</h3>
            <canvas id="player2Canvas" width="300" height="300" class="mx-auto"></canvas>
            <button id="player2ClearBtn" class="btn btn-danger mt-2">Clear Drawing</button>

            <h3 class="text-xl font-semibold mt-4 text-center">Rock Paper Scissors:</h3>
            <div class="flex justify-center gap-3 mt-2">
                <button id="player2RockBtn" class="btn btn-primary rps-btn" data-player="2" data-choice="rock">Rock</button>
                <button id="player2PaperBtn" class="btn btn-primary rps-btn" data-player="2" data-choice="paper">Paper</button>
                <button id="player2ScissorsBtn" class="btn btn-primary rps-btn" data-player="2" data-choice="scissors">Scissors</button>
            </div>

            <h3 class="text-xl font-semibold mt-4 text-center">Actions:</h3>
            <div class="flex flex-col gap-3 mt-2">
                <button id="player2DefendBtn" class="btn btn-success action-btn" data-player="2">Defend (+2 Defense)</button>
                <button id="player2AttackBtn" class="btn btn-warning action-btn" data-player="2">Attack Opponent</button>
                <button id="player2BuyWeaponBtn" class="btn btn-primary action-btn" data-player="2">Buy Weapon</button>
            </div>

            <h3 class="text-xl font-semibold mt-4 text-center">Your Weapons:</h3>
            <ul id="player2WeaponsList" class="flex flex-col gap-2 mt-2">
                <!-- Weapons will be dynamically added here -->
            </ul>
        </div>
    </div>

    <!-- Game Message Box -->
    <div id="gameMessageBox" class="message-box fixed bottom-5 left-1/2 -translate-x-1/2 w-11/12 md:w-1/2 z-50 hidden">
        <p id="gameMessageText" class=""></p>
        <button id="gameMessageCloseBtn" class="btn btn-primary mt-3 mx-auto">OK</button>
    </div>

    <!-- Modal for Weapon Shop / Weapon Selection -->
    <div id="gameModal" class="modal hidden">
        <div class="modal-content">
            <span class="modal-close-btn" id="modalCloseBtn">&times;</span>
            <h3 id="modalTitle" class="text-2xl font-bold text-blue-300 mb-4"></h3>
            <div id="modalBody" class="flex flex-col gap-3">
                <!-- Content will be injected here -->
            </div>
            <div id="modalButtons" class="modal-buttons">
                <!-- Buttons will be injected here -->
            </div>
        </div>
    </div>

    <script type="module">
        // Firebase imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, query, where, addDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // --- Firebase Configuration & Initialization ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');

        let app;
        let db;
        let auth;
        let currentUserId = null;
        let gameRef = null; // Reference to the current game document in Firestore
        let unsubscribeGameListener = null; // To stop listening to game updates

        // Initialize Firebase
        if (Object.keys(firebaseConfig).length > 0) {
            app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    currentUserId = user.uid;
                    document.getElementById('currentUserId').textContent = currentUserId;
                    console.log("Authenticated with Firebase. User ID:", currentUserId);
                } else {
                    console.log("No user signed in. Attempting anonymous sign-in.");
                    try {
                        if (typeof __initial_auth_token !== 'undefined') {
                            await signInWithCustomToken(auth, __initial_auth_token);
                        } else {
                            await signInAnonymously(auth);
                        }
                    } catch (error) {
                        console.error("Firebase authentication failed:", error);
                        showMessageBox("Failed to connect to game server. Please try again later.");
                    }
                }
            });
        } else {
            console.error("Firebase config not found. Running in local-only mode (multiplayer features disabled).");
            document.getElementById('currentUserId').textContent = 'Local Mode';
            document.getElementById('joinGameBtn').disabled = true;
            document.getElementById('createGameBtn').disabled = true;
            showMessageBox("Firebase is not configured. Multiplayer features are disabled. You can still play locally by refreshing.");
        }

        // Game state variables
        const initialHealth = 10;
        let players = {
            player1: {
                health: initialHealth,
                wins: 0,
                defense: 0,
                weapons: [],
                drawingDataURL: '', // Stores the base64 image of the drawing
                lastRPSChoice: null,
                userId: null // Firebase UID of player 1
            },
            player2: {
                health: initialHealth,
                wins: 0,
                defense: 0,
                weapons: [],
                drawingDataURL: '',
                lastRPSChoice: null,
                userId: null // Firebase UID of player 2
            }
        };

        // Weapon definitions
        const weapons = [
            { name: "Laser", cost: 1, damage: 1 },
            { name: "Pistol", cost: 2, damage: 3 },
            { name: "Gun", cost: 3, damage: 5 },
            { name: "Shotgun", cost: 4, damage: 7 },
            { name: "Grenade", cost: 5, damage: 9 }
        ];

        let gamePhase = 'lobby'; // 'lobby', 'drawing', 'rps', 'action_choice', 'game_over'
        let currentPlayerTurn = null; // Which player's UID is currently making an RPS choice or action choice
        let rpsChoices = { player1: null, player2: null }; // Stores 'rock', 'paper', 'scissors'
        let winnerOfRPS = null; // Stores UID of RPS winner

        let myPlayerId = null; // 'player1' or 'player2' for the current user
        let opponentPlayerId = null; // 'player1' or 'player2' for the opponent

        // DOM Elements
        const lobbySection = document.getElementById('lobbySection');
        const gameIdInput = document.getElementById('gameIdInput');
        const joinGameBtn = document.getElementById('joinGameBtn');
        const createGameBtn = document.getElementById('createGameBtn');
        const lobbyMessage = document.getElementById('lobbyMessage');
        const gameContainer = document.getElementById('gameContainer');

        const player1Canvas = document.getElementById('player1Canvas');
        const player1Ctx = player1Canvas.getContext('2d');
        const player1ClearBtn = document.getElementById('player1ClearBtn');
        const player1HealthBar = document.getElementById('player1HealthBar');
        const player1HealthText = document.getElementById('player1Health');
        const player1WinsText = document.getElementById('player1Wins');
        const player1DefenseText = document.getElementById('player1Defense');
        const player1WeaponsList = document.getElementById('player1WeaponsList');
        const player1Status = document.getElementById('player1Status');

        const player2Canvas = document.getElementById('player2Canvas');
        const player2Ctx = player2Canvas.getContext('2d');
        const player2ClearBtn = document.getElementById('player2ClearBtn');
        const player2HealthBar = document.getElementById('player2HealthBar');
        const player2HealthText = document.getElementById('player2Health');
        const player2WinsText = document.getElementById('player2Wins');
        const player2DefenseText = document.getElementById('player2Defense');
        const player2WeaponsList = document.getElementById('player2WeaponsList');
        const player2Status = document.getElementById('player2Status');

        const rpsButtons = document.querySelectorAll('.rps-btn');
        const actionButtons = document.querySelectorAll('.action-btn');

        const gameMessageBox = document.getElementById('gameMessageBox');
        const gameMessageText = document.getElementById('gameMessageText');
        const gameMessageCloseBtn = document.getElementById('gameMessageCloseBtn');

        const gameModal = document.getElementById('gameModal');
        const modalCloseBtn = document.getElementById('modalCloseBtn');
        const modalTitle = document.getElementById('modalTitle');
        const modalBody = document.getElementById('modalBody');
        const modalButtons = document.getElementById('modalButtons');

        // --- Utility Functions ---

        /**
         * Displays a message box to the user.
         * @param {string} message The message to display.
         * @param {function} [callback] An optional callback function to execute when the message box is closed.
         */
        function showMessageBox(message, callback = null) {
            gameMessageText.textContent = message;
            gameMessageBox.classList.remove('hidden');
            gameMessageCloseBtn.onclick = () => {
                gameMessageBox.classList.add('hidden');
                if (callback) {
                    callback();
                }
            };
        }

        /**
         * Shows a generic modal with custom content and buttons.
         * @param {string} title The title of the modal.
         * @param {string} bodyHtml The HTML content for the modal body.
         * @param {Array<Object>} buttons An array of button objects: [{ text: 'Button Text', class: 'btn-primary', onClick: function }]
         * @param {boolean} [closable=true] Whether the modal can be closed by clicking the 'x' button.
         */
        function showModal(title, bodyHtml, buttons, closable = true) {
            modalTitle.textContent = title;
            modalBody.innerHTML = bodyHtml;
            modalButtons.innerHTML = ''; // Clear previous buttons

            buttons.forEach(btnConfig => {
                const button = document.createElement('button');
                button.textContent = btnConfig.text;
                button.className = `btn ${btnConfig.class || 'btn-primary'}`;
                button.onclick = () => {
                    hideModal(); // Hide modal before executing button's action
                    if (btnConfig.onClick) {
                        btnConfig.onClick();
                    }
                };
                modalButtons.appendChild(button);
            });

            if (closable) {
                modalCloseBtn.classList.remove('hidden');
                modalCloseBtn.onclick = hideModal;
            } else {
                modalCloseBtn.classList.add('hidden');
            }
            gameModal.classList.remove('hidden');
        }

        /**
         * Hides the currently active modal.
         */
        function hideModal() {
            gameModal.classList.add('hidden');
        }

        /**
         * Updates the UI elements for a specific player.
         * @param {string} playerId 'player1' or 'player2'.
         */
        function updatePlayerUI(playerId) {
            const player = players[playerId];
            const healthBar = document.getElementById(`${playerId}HealthBar`);
            const healthText = document.getElementById(`${playerId}Health`);
            const winsText = document.getElementById(`${playerId}Wins`);
            const defenseText = document.getElementById(`${playerId}Defense`);
            const weaponsList = document.getElementById(`${playerId}WeaponsList`);
            const playerStatus = document.getElementById(`${playerId}Status`);

            healthText.textContent = player.health;
            healthBar.style.width = `${(player.health / initialHealth) * 100}%`;
            healthBar.style.backgroundColor = player.health > initialHealth / 2 ? '#48bb78' : (player.health > initialHealth / 4 ? '#ecc94b' : '#e53e3e');

            winsText.textContent = player.wins;
            defenseText.textContent = player.defense;

            // Update player status (e.g., "You", "Opponent", "Waiting...")
            if (player.userId === currentUserId) {
                playerStatus.textContent = 'You';
                playerStatus.classList.remove('text-red-300');
                playerStatus.classList.add('text-green-300');
            } else if (player.userId) {
                playerStatus.textContent = 'Opponent';
                playerStatus.classList.remove('text-green-300');
                playerStatus.classList.add('text-red-300');
            } else {
                playerStatus.textContent = 'Waiting...';
                playerStatus.classList.remove('text-green-300', 'text-red-300');
            }

            // Update weapons list
            weaponsList.innerHTML = '';
            if (player.weapons.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'No weapons owned.';
                li.className = 'text-center text-gray-400';
                weaponsList.appendChild(li);
            } else {
                player.weapons.forEach(weapon => {
                    const li = document.createElement('li');
                    li.className = 'weapon-item owned';
                    li.innerHTML = `<span>${weapon.name}</span> <span>Damage: ${weapon.damage}</span>`;
                    weaponsList.appendChild(li);
                });
            }
        }

        /**
         * Disables or enables a set of buttons.
         * @param {NodeListOf<Element>} buttons The NodeList of buttons to modify.
         * @param {boolean} isDisabled True to disable, false to enable.
         */
        function setButtonsDisabled(buttons, isDisabled) {
            buttons.forEach(button => {
                button.disabled = isDisabled;
                if (isDisabled) {
                    button.classList.add('btn-disabled');
                    button.classList.remove('btn-primary', 'btn-success', 'btn-danger', 'btn-warning');
                } else {
                    button.classList.remove('btn-disabled');
                    // Restore original button styles based on their data attributes or default
                    if (button.classList.contains('rps-btn')) {
                         button.classList.add('btn-primary');
                    } else if (button.id.includes('DefendBtn')) {
                        button.classList.add('btn-success');
                    } else if (button.id.includes('AttackBtn')) {
                        button.classList.add('btn-warning');
                    } else if (button.id.includes('BuyWeaponBtn')) {
                        button.classList.add('btn-primary');
                    } else if (button.id.includes('ClearBtn')) {
                        button.classList.add('btn-danger');
                    }
                }
            });
        }

        /**
         * Manages button states based on the current game phase and player turn.
         */
        function updateButtonStates() {
            // Disable all RPS and action buttons initially
            setButtonsDisabled(rpsButtons, true);
            setButtonsDisabled(actionButtons, true);

            // Enable clear buttons always
            setButtonsDisabled(document.querySelectorAll('[id$="ClearBtn"]'), false);

            // Only enable buttons for the current user's player section
            const myPlayerSection = document.getElementById(`${myPlayerId}Section`);
            const opponentPlayerSection = document.getElementById(`${opponentPlayerId}Section`);

            if (gamePhase === 'drawing') {
                // Drawing is always enabled for both players until RPS starts
                // No buttons to enable/disable based on turn here
            } else if (gamePhase === 'rps') {
                if (currentPlayerTurn === currentUserId) {
                    setButtonsDisabled(myPlayerSection.querySelectorAll('.rps-btn'), false);
                    setButtonsDisabled(opponentPlayerSection.querySelectorAll('.rps-btn'), true);
                } else {
                    setButtonsDisabled(myPlayerSection.querySelectorAll('.rps-btn'), true);
                    setButtonsDisabled(opponentPlayerSection.querySelectorAll('.rps-btn'), true);
                }
            } else if (gamePhase === 'action_choice') {
                if (winnerOfRPS === currentUserId) {
                    setButtonsDisabled(myPlayerSection.querySelectorAll('.action-btn'), false);
                    setButtonsDisabled(opponentPlayerSection.querySelectorAll('.action-btn'), true);
                } else {
                    setButtonsDisabled(myPlayerSection.querySelectorAll('.action-btn'), true);
                    setButtonsDisabled(opponentPlayerSection.querySelectorAll('.action-btn'), true);
                }
            } else if (gamePhase === 'game_over') {
                // All buttons remain disabled
            }
        }

        // --- Drawing Logic ---
        /**
         * Sets up drawing functionality for a given canvas.
         * @param {HTMLCanvasElement} canvas The canvas element.
         * @param {CanvasRenderingContext2D} ctx The 2D rendering context of the canvas.
         * @param {string} playerId 'player1' or 'player2'.
         */
        function setupDrawing(canvas, ctx, playerId) {
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;

            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#000000'; // Black drawing color

            function getCoords(e) {
                const rect = canvas.getBoundingClientRect();
                if (e.touches && e.touches.length > 0) {
                    return {
                        x: e.touches[0].clientX - rect.left,
                        y: e.touches[0].clientY - rect.top
                    };
                }
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }

            function startDrawing(e) {
                // Only allow drawing if it's your canvas and game is in drawing phase
                if (gamePhase !== 'drawing' || players[playerId].userId !== currentUserId) return;
                isDrawing = true;
                const coords = getCoords(e);
                [lastX, lastY] = [coords.x, coords.y];
            }

            function draw(e) {
                if (!isDrawing) return;
                const coords = getCoords(e);
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(coords.x, coords.y);
                ctx.stroke();
                [lastX, lastY] = [coords.x, coords.y];
            }

            function stopDrawing() {
                if (isDrawing) {
                    isDrawing = false;
                    // Save drawing to Firestore after drawing is stopped
                    saveDrawingToFirestore(playerId, canvas.toDataURL());
                }
            }

            // Mouse events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);

            // Touch events
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent scrolling
                startDrawing(e);
            });
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault(); // Prevent scrolling
                draw(e);
            });
            canvas.addEventListener('touchend', stopDrawing);
            canvas.addEventListener('touchcancel', stopDrawing);
        }

        /**
         * Clears the drawing on a specified canvas.
         * @param {CanvasRenderingContext2D} ctx The 2D rendering context of the canvas.
         * @param {HTMLCanvasElement} canvas The canvas element.
         * @param {string} playerId 'player1' or 'player2'.
         */
        function clearCanvas(ctx, canvas, playerId) {
            if (players[playerId].userId !== currentUserId) {
                showMessageBox("You can only clear your own drawing!");
                return;
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            saveDrawingToFirestore(playerId, ''); // Save empty drawing
        }

        /**
         * Saves the canvas drawing as a data URL to Firestore.
         * @param {string} playerId 'player1' or 'player2'.
         * @param {string} dataURL The base64 data URL of the canvas.
         */
        async function saveDrawingToFirestore(playerId, dataURL) {
            if (!gameRef) return;
            try {
                const updateData = {};
                updateData[`${playerId}Data.drawingDataURL`] = dataURL;
                await updateDoc(gameRef, updateData);
            } catch (error) {
                console.error("Error saving drawing to Firestore:", error);
            }
        }

        /**
         * Loads a drawing from a data URL onto a canvas.
         * @param {CanvasRenderingContext2D} ctx The 2D rendering context.
         * @param {HTMLCanvasElement} canvas The canvas element.
         * @param {string} dataURL The base64 data URL of the image.
         */
        function loadDrawingFromDataURL(ctx, canvas, dataURL) {
            clearCanvas(ctx, canvas, 'dummy'); // Clear first
            if (dataURL) {
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                };
                img.src = dataURL;
            }
        }

        // Setup drawing for both players
        setupDrawing(player1Canvas, player1Ctx, 'player1');
        setupDrawing(player2Canvas, player2Ctx, 'player2');

        // Clear button event listeners
        player1ClearBtn.addEventListener('click', () => clearCanvas(player1Ctx, player1Canvas, 'player1'));
        player2ClearBtn.addEventListener('click', () => clearCanvas(player2Ctx, player2Canvas, 'player2'));

        // --- Game Logic ---

        /**
         * Initializes or resets the game state in Firestore.
         * This function should only be called by the player creating the game.
         * @param {string} gameId The ID of the game to initialize.
         * @param {string} creatorUid The UID of the player creating the game.
         */
        async function initializeGameState(gameId, creatorUid) {
            const initialGameState = {
                gamePhase: 'drawing',
                players: {
                    player1: {
                        health: initialHealth,
                        wins: 0,
                        defense: 0,
                        weapons: [],
                        drawingDataURL: '',
                        lastRPSChoice: null,
                        userId: creatorUid
                    },
                    player2: {
                        health: initialHealth,
                        wins: 0,
                        defense: 0,
                        weapons: [],
                        drawingDataURL: '',
                        lastRPSChoice: null,
                        userId: null // Waiting for player 2
                    }
                },
                currentPlayerTurn: creatorUid, // Player 1 starts RPS
                rpsChoices: { player1: null, player2: null },
                winnerOfRPS: null,
                lastActionMessage: `Welcome! Player 1 (${creatorUid.substring(0, 6)}...) has created the game. Waiting for Player 2 to join.`,
                createdAt: new Date().toISOString()
            };

            gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
            await setDoc(gameRef, initialGameState);
            console.log("Game initialized in Firestore with ID:", gameId);
            lobbyMessage.textContent = `Game created! Share this ID: ${gameId}`;
            lobbyMessage.classList.remove('text-red-400');
            lobbyMessage.classList.add('text-green-400');
            startGameListener(gameId);
        }

        /**
         * Joins an existing game.
         * @param {string} gameId The ID of the game to join.
         * @param {string} joinerUid The UID of the player joining.
         */
        async function joinGame(gameId, joinerUid) {
            gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
            const gameDoc = await getDoc(gameRef);

            if (!gameDoc.exists()) {
                lobbyMessage.textContent = "Game not found. Please check the ID or create a new game.";
                return;
            }

            const gameData = gameDoc.data();

            if (gameData.players.player1.userId === joinerUid || gameData.players.player2.userId === joinerUid) {
                lobbyMessage.textContent = "You are already in this game!";
                startGameListener(gameId); // Re-join listener
                return;
            }

            if (gameData.players.player1.userId && gameData.players.player2.userId) {
                lobbyMessage.textContent = "This game is full.";
                return;
            }

            let playerToAssign = null;
            if (!gameData.players.player1.userId) {
                playerToAssign = 'player1';
            } else if (!gameData.players.player2.userId) {
                playerToAssign = 'player2';
            }

            if (playerToAssign) {
                const updateData = {};
                updateData[`players.${playerToAssign}.userId`] = joinerUid;
                updateData.lastActionMessage = `${joinerUid.substring(0, 6)}... has joined the game!`;
                await updateDoc(gameRef, updateData);
                lobbyMessage.textContent = `Joined game ${gameId}!`;
                lobbyMessage.classList.remove('text-red-400');
                lobbyMessage.classList.add('text-green-400');
                startGameListener(gameId);
            } else {
                lobbyMessage.textContent = "Could not join game. Unexpected state.";
            }
        }

        /**
         * Starts listening for real-time updates to the game document.
         * @param {string} gameId The ID of the game to listen to.
         */
        function startGameListener(gameId) {
            if (unsubscribeGameListener) {
                unsubscribeGameListener(); // Unsubscribe from previous listener if any
            }

            gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
            unsubscribeGameListener = onSnapshot(gameRef, (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const gameData = docSnapshot.data();
                    updateLocalGameState(gameData);
                } else {
                    showMessageBox("Game ended or deleted by host. Returning to lobby.", () => {
                        resetGame();
                        lobbySection.classList.remove('hidden');
                        gameContainer.classList.add('hidden');
                    });
                }
            }, (error) => {
                console.error("Error listening to game updates:", error);
                showMessageBox("Lost connection to the game. Please check your internet or try again.", () => {
                    resetGame();
                    lobbySection.classList.remove('hidden');
                    gameContainer.classList.add('hidden');
                });
            });

            lobbySection.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            gameIdInput.value = gameId; // Display the game ID in the input
        }

        /**
         * Updates the local game state based on Firestore data.
         * @param {Object} gameData The game data from Firestore.
         */
        function updateLocalGameState(gameData) {
            // Update core game state
            gamePhase = gameData.gamePhase;
            currentPlayerTurn = gameData.currentPlayerTurn;
            rpsChoices = gameData.rpsChoices;
            winnerOfRPS = gameData.winnerOfRPS;

            // Update player data
            players.player1 = { ...players.player1, ...gameData.players.player1 };
            players.player2 = { ...players.player2, ...gameData.players.player2 };

            // Determine myPlayerId and opponentPlayerId
            if (players.player1.userId === currentUserId) {
                myPlayerId = 'player1';
                opponentPlayerId = 'player2';
            } else if (players.player2.userId === currentUserId) {
                myPlayerId = 'player2';
                opponentPlayerId = 'player1';
            } else {
                // This can happen if a third person is viewing or if initial assignment hasn't happened.
                // For now, we assume a player is either player1 or player2.
                myPlayerId = null;
                opponentPlayerId = null;
            }

            // Update UI
            updatePlayerUI('player1');
            updatePlayerUI('player2');

            // Load drawings
            loadDrawingFromDataURL(player1Ctx, player1Canvas, players.player1.drawingDataURL);
            loadDrawingFromDataURL(player2Ctx, player2Canvas, players.player2.drawingDataURL);

            // Display last action message
            if (gameData.lastActionMessage && gameMessageText.textContent !== gameData.lastActionMessage) {
                showMessageBox(gameData.lastActionMessage);
            }

            // Manage button states
            updateButtonStates();

            // Check if game is ready to start (both players joined)
            if (gamePhase === 'drawing' && players.player1.userId && players.player2.userId && gameData.lastActionMessage.includes('Waiting for Player 2')) {
                // Only the host (player1) should initiate the phase change
                if (myPlayerId === 'player1') {
                    updateDoc(gameRef, {
                        gamePhase: 'rps',
                        lastActionMessage: "Both players joined! Time for Rock-Paper-Scissors. Player 1, make your choice."
                    });
                }
            }

            // Handle game over state locally
            if (gamePhase === 'game_over') {
                // The message box for game over is triggered by checkGameOver() when health drops.
                // If we receive a game_over state from Firestore, ensure the UI reflects it.
                updateButtonStates(); // Disable all buttons
            }
        }


        /**
         * Updates the game state in Firestore.
         * @param {Object} updates An object containing the fields to update.
         */
        async function updateGameState(updates) {
            if (!gameRef) {
                console.error("No active game reference to update.");
                showMessageBox("Error: Not connected to a game. Please create or join one.");
                return;
            }
            try {
                await updateDoc(gameRef, updates);
            } catch (error) {
                console.error("Error updating game state:", error);
                showMessageBox("Failed to update game state. Please try again.");
            }
        }

        /**
         * Handles a player's RPS choice.
         * @param {string} playerId 'player1' or 'player2'.
         * @param {string} choice 'rock', 'paper', or 'scissors'.
         */
        async function handleRPSChoice(playerId, choice) {
            if (gamePhase !== 'rps' || players[playerId].userId !== currentUserId) {
                showMessageBox("It's not your turn or the wrong phase for RPS.");
                return;
            }

            // Prevent double-choice or out-of-turn choice
            if (rpsChoices[playerId] !== null) {
                showMessageBox("You have already made your choice for this round.");
                return;
            }
            if (currentPlayerTurn !== currentUserId) {
                showMessageBox("It's not your turn to choose RPS.");
                return;
            }

            const newRpsChoices = { ...rpsChoices, [playerId]: choice };
            const newLastRPSChoice = choice;

            let updates = {
                [`players.${playerId}.lastRPSChoice`]: newLastRPSChoice,
                [`rpsChoices.${playerId}`]: newRpsChoices[playerId],
                lastActionMessage: `${players[playerId].userId.substring(0, 6)}... chose ${choice}!`
            };

            if (newRpsChoices.player1 && newRpsChoices.player2) {
                // Both players have chosen, determine winner
                const p1Choice = newRpsChoices.player1;
                const p2Choice = newRpsChoices.player2;

                let message = `Player 1 chose ${p1Choice}, Player 2 chose ${p2Choice}. `;
                let newWinnerOfRPS = null;
                let player1Wins = players.player1.wins;
                let player2Wins = players.player2.wins;

                if (p1Choice === p2Choice) {
                    message += "It's a tie! No one wins this round. Starting a new RPS round.";
                    updates.gamePhase = 'rps'; // Restart RPS
                    updates.rpsChoices = { player1: null, player2: null };
                    updates.currentPlayerTurn = players.player1.userId; // Player 1 starts next RPS
                } else if (
                    (p1Choice === 'rock' && p2Choice === 'scissors') ||
                    (p1Choice === 'paper' && p2Choice === 'rock') ||
                    (p1Choice === 'scissors' && p2Choice === 'paper')
                ) {
                    newWinnerOfRPS = players.player1.userId;
                    player1Wins++;
                    message += `${players.player1.userId.substring(0, 6)}... wins the RPS round! They can now choose an action.`;
                    updates.gamePhase = 'action_choice';
                    updates.winnerOfRPS = newWinnerOfRPS;
                    updates[`players.player1.wins`] = player1Wins;
                    updates.rpsChoices = { player1: null, player2: null }; // Reset for next round
                } else {
                    newWinnerOfRPS = players.player2.userId;
                    player2Wins++;
                    message += `${players.player2.userId.substring(0, 6)}... wins the RPS round! They can now choose an action.`;
                    updates.gamePhase = 'action_choice';
                    updates.winnerOfRPS = newWinnerOfRPS;
                    updates[`players.player2.wins`] = player2Wins;
                    updates.rpsChoices = { player1: null, player2: null }; // Reset for next round
                }
                updates.lastActionMessage = message;
                updates.currentPlayerTurn = newWinnerOfRPS; // Winner makes the next move
            } else {
                // Only one player has chosen, switch turn
                updates.currentPlayerTurn = (players.player1.userId === currentUserId) ? players.player2.userId : players.player1.userId;
                updates.lastActionMessage = `${updates.currentPlayerTurn.substring(0, 6)}..., make your choice!`;
            }

            await updateGameState(updates);
        }

        /**
         * Handles the winner's chosen action.
         * @param {string} action 'defend', 'attack', or 'buy_weapon'.
         */
        async function handleActionChoice(action) {
            if (gamePhase !== 'action_choice' || winnerOfRPS !== currentUserId) {
                showMessageBox("It's not your turn or the wrong phase for action.");
                return;
            }

            const winnerPlayerId = myPlayerId; // The current user is the winner
            const winnerPlayer = players[winnerPlayerId];
            const opponentPlayerId = (winnerPlayerId === 'player1' ? 'player2' : 'player1');
            const opponentPlayer = players[opponentPlayerId];

            let updates = {};
            let message = "";
            let proceedToNextRound = true;

            switch (action) {
                case 'defend':
                    updates[`players.${winnerPlayerId}.defense`] = winnerPlayer.defense + 2;
                    message = `${winnerPlayerId === 'player1' ? 'Player 1' : 'Player 2'} chose to defend, gaining 2 defense points!`;
                    break;
                case 'attack':
                    if (winnerPlayer.weapons.length === 0) {
                        showMessageBox("You have no weapons to attack with! Choose another action or buy a weapon.");
                        proceedToNextRound = false; // Stay in action_choice phase
                        return;
                    }
                    showWeaponSelectionModal(winnerPlayerId);
                    proceedToNextRound = false; // Wait for weapon selection
                    break;
                case 'buy_weapon':
                    showWeaponShopModal(winnerPlayerId);
                    proceedToNextRound = false; // Wait for weapon purchase
                    break;
            }

            if (proceedToNextRound) {
                updates.lastActionMessage = message;
                updates.gamePhase = 'rps'; // Move to next RPS round
                updates.currentPlayerTurn = players.player1.userId; // Player 1 starts next RPS
                updates[`players.player1.defense`] = 0; // Reset defenses
                updates[`players.player2.defense`] = 0; // Reset defenses
                await updateGameState(updates);
                checkGameOver(); // Check game over after health update
            } else if (action !== 'attack' && action !== 'buy_weapon') {
                 // If an action was taken but not attack/buy, update state and check game over
                updates.lastActionMessage = message;
                await updateGameState(updates);
                checkGameOver();
            }
        }

        /**
         * Displays the weapon shop modal.
         * @param {string} playerId The ID of the player who is buying the weapon.
         */
        function showWeaponShopModal(playerId) {
            const player = players[playerId];
            let bodyHtml = `<p class="text-center text-lg mb-4">Your Wins: ${player.wins}</p>`;
            bodyHtml += `<ul class="flex flex-col gap-2">`;
            weapons.forEach(weapon => {
                const canAfford = player.wins >= weapon.cost;
                const owned = player.weapons.some(w => w.name === weapon.name);
                bodyHtml += `
                    <li class="weapon-item ${owned ? 'owned' : ''} ${!canAfford && !owned ? 'opacity-50' : ''}">
                        <span>${weapon.name} (Cost: ${weapon.cost} Wins, Damage: ${weapon.damage})</span>
                        <button class="btn ${canAfford && !owned ? 'btn-success' : 'btn-disabled'}"
                                ${!canAfford || owned ? 'disabled' : ''}
                                onclick="window.buyWeapon('${playerId}', '${weapon.name}')">
                            ${owned ? 'Owned' : 'Buy'}
                        </button>
                    </li>
                `;
            });
            bodyHtml += `</ul>`;

            showModal("Weapon Shop", bodyHtml, [
                { text: 'Close', class: 'btn-primary', onClick: async () => {
                    // After closing, proceed to next round if no weapon was bought
                    await updateGameState({
                        lastActionMessage: "Weapon shop closed. Starting next RPS round.",
                        gamePhase: 'rps',
                        currentPlayerTurn: players.player1.userId,
                        [`players.player1.defense`]: 0, // Reset defenses
                        [`players.player2.defense`]: 0  // Reset defenses
                    });
                    checkGameOver();
                }}
            ], false); // Not closable by 'x' button, must choose an action
        }

        /**
         * Handles the purchase of a weapon.
         * @param {string} playerId 'player1' or 'player2'.
         * @param {string} weaponName The name of the weapon to buy.
         */
        window.buyWeapon = async function(playerId, weaponName) { // Made global for onclick
            const player = players[playerId];
            const weapon = weapons.find(w => w.name === weaponName);

            if (!weapon) {
                showMessageBox("Invalid weapon selected.");
                return;
            }
            if (player.wins < weapon.cost) {
                showMessageBox("Not enough wins to buy this weapon!");
                return;
            }
            if (player.weapons.some(w => w.name === weapon.name)) {
                showMessageBox("You already own this weapon!");
                return;
            }

            const updatedWeapons = [...player.weapons, weapon];
            const updatedWins = player.wins - weapon.cost;

            hideModal(); // Close weapon shop modal

            await updateGameState({
                [`players.${playerId}.wins`]: updatedWins,
                [`players.${playerId}.weapons`]: updatedWeapons,
                lastActionMessage: `${playerId === 'player1' ? 'Player 1' : 'Player 2'} bought a ${weapon.name}! Starting next RPS round.`,
                gamePhase: 'rps',
                currentPlayerTurn: players.player1.userId,
                [`players.player1.defense`]: 0, // Reset defenses
                [`players.player2.defense`]: 0  // Reset defenses
            });
            checkGameOver();
        }

        /**
         * Displays the weapon selection modal for attacking.
         * @param {string} attackerId The ID of the player who is attacking.
         */
        function showWeaponSelectionModal(attackerId) {
            const attacker = players[attackerId];
            let bodyHtml = `<p class="text-center text-lg mb-4">Select a weapon to attack:</p>`;
            bodyHtml += `<ul class="flex flex-col gap-2">`;
            if (attacker.weapons.length === 0) {
                bodyHtml += `<li class="text-center text-gray-400">You have no weapons!</li>`;
            } else {
                attacker.weapons.forEach(weapon => {
                    bodyHtml += `
                        <li class="weapon-item owned">
                            <span>${weapon.name} (Damage: ${weapon.damage})</span>
                            <button class="btn btn-warning"
                                    onclick="window.performAttack('${attackerId}', '${weapon.name}')">
                                Attack with ${weapon.name}
                            </button>
                        </li>
                    `;
                });
            }
            bodyHtml += `</ul>`;

            showModal("Select Weapon", bodyHtml, [
                { text: 'Cancel', class: 'btn-danger', onClick: () => {
                    showMessageBox("Attack cancelled. Please choose another action.");
                    // Re-enable action buttons for the winner to choose again (handled by updateButtonStates on next render)
                }}
            ], false); // Not closable by 'x' button, must choose an action or cancel
        }

        /**
         * Performs the attack using the selected weapon.
         * @param {string} attackerId 'player1' or 'player2'.
         * @param {string} weaponName The name of the weapon used.
         */
        window.performAttack = async function(attackerId, weaponName) { // Made global for onclick
            const attacker = players[attackerId];
            const defenderId = attackerId === 'player1' ? 'player2' : 'player1';
            const defender = players[defenderId];
            const weapon = attacker.weapons.find(w => w.name === weaponName);

            if (!weapon) {
                showMessageBox("Error: Weapon not found.");
                return;
            }

            let damageDealt = weapon.damage - defender.defense;
            if (damageDealt < 0) damageDealt = 0; // Cannot heal opponent

            const updatedDefenderHealth = defender.health - damageDealt;

            hideModal(); // Close weapon selection modal

            await updateGameState({
                [`players.${defenderId}.health`]: updatedDefenderHealth < 0 ? 0 : updatedDefenderHealth,
                lastActionMessage: `${attackerId === 'player1' ? 'Player 1' : 'Player 2'} attacked ${defenderId === 'player1' ? 'Player 1' : 'Player 2'} with ${weapon.name}, dealing ${damageDealt} damage!`,
                gamePhase: 'rps',
                currentPlayerTurn: players.player1.userId,
                [`players.player1.defense`]: 0, // Reset defenses
                [`players.player2.defense`]: 0  // Reset defenses
            });
            checkGameOver();
        }

        /**
         * Checks if the game is over and declares the winner.
         * This function should be called after any health update.
         */
        async function checkGameOver() {
            if (players.player1.health <= 0) {
                await updateGameState({
                    gamePhase: 'game_over',
                    lastActionMessage: `Player 1's health reached 0! Player 2 (${players.player2.userId.substring(0,6)}...) wins the game! Click OK to restart.`
                });
                showMessageBox("Game Over! Player 2 wins! Click OK to restart.", resetGame);
            } else if (players.player2.health <= 0) {
                await updateGameState({
                    gamePhase: 'game_over',
                    lastActionMessage: `Player 2's health reached 0! Player 1 (${players.player1.userId.substring(0,6)}...) wins the game! Click OK to restart.`
                });
                showMessageBox("Game Over! Player 1 wins! Click OK to restart.", resetGame);
            }
        }

        /**
         * Resets the game to the lobby state.
         */
        async function resetGame() {
            if (unsubscribeGameListener) {
                unsubscribeGameListener();
                unsubscribeGameListener = null;
            }
            gameRef = null;
            myPlayerId = null;
            opponentPlayerId = null;
            gamePhase = 'lobby';
            currentPlayerTurn = null;
            rpsChoices = { player1: null, player2: null };
            winnerOfRPS = null;

            // Reset local player states
            players.player1 = { health: initialHealth, wins: 0, defense: 0, weapons: [], drawingDataURL: '', lastRPSChoice: null, userId: null };
            players.player2 = { health: initialHealth, wins: 0, defense: 0, weapons: [], drawingDataURL: '', lastRPSChoice: null, userId: null };

            clearCanvas(player1Ctx, player1Canvas, 'player1');
            clearCanvas(player2Ctx, player2Canvas, 'player2');
            updatePlayerUI('player1');
            updatePlayerUI('player2');
            updateButtonStates();

            gameIdInput.value = '';
            lobbyMessage.textContent = '';
            lobbySection.classList.remove('hidden');
            gameContainer.classList.add('hidden');
            showMessageBox("Game has been reset. You can create or join a new game.");
        }

        // --- Lobby Event Listeners ---
        createGameBtn.addEventListener('click', async () => {
            if (!currentUserId) {
                showMessageBox("Please wait, authenticating with Firebase...");
                return;
            }
            lobbyMessage.textContent = 'Creating game...';
            lobbyMessage.classList.remove('text-red-400');
            lobbyMessage.classList.add('text-yellow-400');
            const newGameId = crypto.randomUUID().substring(0, 8); // Simple unique ID
            await initializeGameState(newGameId, currentUserId);
        });

        joinGameBtn.addEventListener('click', async () => {
            if (!currentUserId) {
                showMessageBox("Please wait, authenticating with Firebase...");
                return;
            }
            const gameId = gameIdInput.value.trim();
            if (gameId) {
                lobbyMessage.textContent = 'Joining game...';
                lobbyMessage.classList.remove('text-red-400');
                lobbyMessage.classList.add('text-yellow-400');
                await joinGame(gameId, currentUserId);
            } else {
                lobbyMessage.textContent = "Please enter a Game ID.";
                lobbyMessage.classList.add('text-red-400');
            }
        });

        // --- Game Event Listeners ---

        // RPS Buttons
        rpsButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                const playerId = `player${e.target.dataset.player}`;
                const choice = e.target.dataset.choice;
                handleRPSChoice(playerId, choice);
            });
        });

        // Action Buttons
        actionButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                const playerId = `player${e.target.dataset.player}`;
                // Ensure only the winner can click their action buttons
                if (players[playerId].userId !== winnerOfRPS) {
                    showMessageBox("It's not your turn to choose an action!");
                    return;
                }

                if (e.target.id.includes('Defend')) {
                    handleActionChoice('defend');
                } else if (e.target.id.includes('Attack')) {
                    handleActionChoice('attack');
                } else if (e.target.id.includes('BuyWeapon')) {
                    handleActionChoice('buy_weapon');
                }
            });
        });

        // Initial setup when page loads
        window.onload = () => {
            // No need to call initializeGame directly, Firebase auth listener will handle it.
            // The lobby is shown initially.
            updateButtonStates(); // Ensure buttons are correctly disabled/enabled
        };

    </script>
</body>
</html>
