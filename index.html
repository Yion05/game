<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>RPS Drawing Battle</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 20px;
            box-sizing: border-box;
        }
        .game-container {
            background-color: #2d3748; /* Slightly lighter dark background */
            border-radius: 1.5rem; /* More rounded corners */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4); /* Stronger shadow */
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 25px;
            max-width: 1200px;
            width: 100%;
        }
        .player-section {
            background-color: #4a5568; /* Even lighter dark background for sections */
            border-radius: 1rem;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
        }
        canvas {
            border: 2px solid #63b3ed; /* Blue border for canvas */
            background-color: #ffffff; /* White drawing area */
            border-radius: 0.75rem;
            cursor: crosshair;
            touch-action: none; /* Prevent default touch actions like scrolling/zooming */
        }
        .health-bar-container {
            width: 100%;
            background-color: #e53e3e; /* Red for health bar background */
            border-radius: 0.5rem;
            height: 25px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .health-bar {
            height: 100%;
            background-color: #48bb78; /* Green for health */
            border-radius: 0.5rem;
            transition: width 0.5s ease-in-out;
        }
        .btn {
            padding: 12px 20px;
            border-radius: 0.75rem;
            font-weight: 600;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            border: none;
            outline: none;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
        }
        .btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .btn-primary {
            background-color: #63b3ed; /* Blue */
            color: #1a202c;
        }
        .btn-primary:hover {
            background-color: #4299e1;
        }
        .btn-success {
            background-color: #48bb78; /* Green */
            color: #1a202c;
        }
        .btn-success:hover {
            background-color: #38a169;
        }
        .btn-danger {
            background-color: #e53e3e; /* Red */
            color: #1a202c;
        }
        .btn-danger:hover {
            background-color: #c53030;
        }
        .btn-warning {
            background-color: #ecc94b; /* Yellow */
            color: #1a202c;
        }
        .btn-warning:hover {
            background-color: #d69e2e;
        }
        .btn-disabled {
            background-color: #a0aec0; /* Gray */
            color: #4a5568;
            cursor: not-allowed;
            box-shadow: none;
        }
        .btn-disabled:hover {
            transform: none;
            box-shadow: none;
        }

        .message-box {
            background-color: #2c5282; /* Darker blue for messages */
            border-radius: 0.75rem;
            padding: 15px;
            text-align: center;
            font-size: 1.1rem;
            font-weight: 600;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .weapon-item {
            background-color: #63b3ed;
            color: #1a202c;
            padding: 8px 12px;
            border-radius: 0.5rem;
            font-size: 0.9rem;
            font-weight: 500;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .weapon-item.owned {
            background-color: #48bb78;
        }

        /* Responsive adjustments */
        @media (min-width: 768px) {
            .game-container {
                flex-direction: row;
                justify-content: space-around;
                align-items: flex-start;
            }
            .player-section {
                width: 48%; /* Adjust width for two columns */
            }
        }
        @media (max-width: 767px) {
            .game-container {
                flex-direction: column;
            }
            .player-section {
                width: 100%;
            }
        }

        /* Modal styles */
        .modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(5px);
            -webkit-backdrop-filter: blur(5px);
        }
        .modal-content {
            background-color: #2d3748;
            padding: 30px;
            border-radius: 1.5rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.5);
            max-width: 500px;
            width: 90%;
            text-align: center;
            position: relative;
            animation: fadeIn 0.3s ease-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-20px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .modal-close-btn {
            position: absolute;
            top: 15px;
            right: 20px;
            font-size: 1.8rem;
            cursor: pointer;
            color: #e2e8f0;
        }
        .modal-close-btn:hover {
            color: #cbd5e0;
        }
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-top: 25px;
        }
        .lobby-section {
            background-color: #2d3748;
            border-radius: 1.5rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.4);
            padding: 30px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-width: 600px;
            width: 100%;
            text-align: center;
        }
        .loading-spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid #63b3ed;
            border-radius: 50%;
            width: 30px;
            height: 30px;
            animation: spin 1s linear infinite;
            margin: 0 auto;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* RPS Button Styling */
        .rps-gif-btn {
            background-color: #63b3ed; /* Blue */
            border-radius: 0.75rem;
            padding: 8px; /* Reduced padding for image */
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            cursor: pointer;
            border: none;
            outline: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            width: 100px; /* Fixed width for consistency */
            height: 100px; /* Fixed height for consistency */
        }
        .rps-gif-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
        }
        .rps-gif-btn:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        .rps-gif-btn.btn-disabled {
            background-color: #a0aec0; /* Gray */
            color: #4a5568;
            cursor: not-allowed;
            box-shadow: none;
        }
        .rps-gif-btn.btn-disabled:hover {
            transform: none;
            box-shadow: none;
        }
        .rps-gif-btn img {
            width: 60px; /* Size of the GIF */
            height: 60px;
            object-fit: contain;
            border-radius: 0.5rem; /* Rounded corners for the image */
        }
        .rps-gif-btn span {
            font-size: 0.8rem;
            font-weight: 600;
            color: #1a202c;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 flex items-center justify-center min-h-screen p-5">

    <div id="lobbySection" class="lobby-section">
        <h2 class="text-3xl font-bold text-center text-blue-300">RPS Drawing Battle</h2>
        <p class="text-lg text-center">Your User ID: <span id="currentUserId" class="font-bold text-yellow-300">Loading...</span></p>

        <div class="flex flex-col gap-4">
            <input type="text" id="gameIdInput" placeholder="Enter Game ID to Join"
                   class="p-3 rounded-lg bg-gray-700 text-gray-100 border border-gray-600 focus:outline-none focus:border-blue-400">
            <button id="joinGameBtn" class="btn btn-primary">Join Game</button>
            <div class="text-center text-lg">OR</div>
            <button id="createGameBtn" class="btn btn-success">Create New Game</button>
            <div class="text-center text-lg">OR</div>
            <button id="findMatchBtn" class="btn btn-warning">Find Match</button>
            <button id="cancelMatchmakingBtn" class="btn btn-danger hidden">Cancel Matchmaking</button>
        </div>
        <div id="lobbyMessage" class="text-red-400 text-sm mt-2"></div>
    </div>

    <div id="gameContainer" class="game-container hidden">
        <div id="player1Section" class="player-section">
            <h2 class="text-2xl font-bold text-center text-blue-300">Player 1 (<span id="player1Status">Waiting...</span>)</h2>
            <div class="health-bar-container">
                <div id="player1HealthBar" class="health-bar" style="width: 100%;"></div>
            </div>
            <p class="text-lg text-center">Health: <span id="player1Health">10</span></p>
            <p class="text-lg text-center">Coins: <span id="player1Coins">0</span></p>
            <p class="text-lg text-center">Defense: <span id="player1Defense">0</span></p>

            <h3 class="text-xl font-semibold mt-4 text-center">Draw Your Character:</h3>
            <canvas id="player1Canvas" width="300" height="300" class="mx-auto"></canvas>
            <button id="player1ClearBtn" class="btn btn-danger mt-2">Clear Drawing</button>
            <button id="player1ConfirmDrawingBtn" class="btn btn-primary mt-2">Confirm Drawing</button>

            <h3 class="text-xl font-semibold mt-4 text-center">Rock Paper Scissors:</h3>
            <div class="flex justify-center gap-3 mt-2">
                <button id="player1RockBtn" class="rps-gif-btn rps-btn" data-player="1" data-choice="rock">
                    <img src="https://editablegifs.com/gifs/gifs/rock-paper-scissors-2/thumbnail.gif" alt="Rock GIF" onerror="this.onerror=null;this.src='https://placehold.co/60x60/63b3ed/FFFFFF?text=ROCK';">
                    <span>Rock</span>
                </button>
                <button id="player1PaperBtn" class="rps-gif-btn rps-btn" data-player="1" data-choice="paper">
                    <img src="https://editablegifs.com/gifs/gifs/rock-paper-scissors-3/thumbnail.gif" alt="Paper GIF" onerror="this.onerror=null;this.src='https://placehold.co/60x60/63b3ed/FFFFFF?text=PAPER';">
                    <span>Paper</span>
                </button>
                <button id="player1ScissorsBtn" class="rps-gif-btn rps-btn" data-player="1" data-choice="scissors">
                    <img src="https://editablegifs.com/gifs/gifs/rock-paper-scissors-4/thumbnail.gif" alt="Scissors GIF" onerror="this.onerror=null;this.src='https://placehold.co/60x60/63b3ed/FFFFFF?text=SCISSORS';">
                    <span>Scissors</span>
                </button>
            </div>

            <h3 class="text-xl font-semibold mt-4 text-center">Actions:</h3>
            <div class="flex flex-col gap-3 mt-2">
                <button id="player1DefendBtn" class="btn btn-success action-btn" data-player="1">Defend (+1 Health, -1 Coin)</button>
                <button id="player1AttackBtn" class="btn btn-warning action-btn" data-player="1">Attack Opponent</button>
                <button id="player1BuyWeaponBtn" class="btn btn-primary action-btn" data-player="1">Buy Weapon</button>
            </div>

            <h3 class="text-xl font-semibold mt-4 text-center">Your Weapons:</h3>
            <ul id="player1WeaponsList" class="flex flex-col gap-2 mt-2">
                </ul>
        </div>

        <div id="player2Section" class="player-section">
            <h2 class="text-2xl font-bold text-center text-blue-300">Player 2 (<span id="player2Status">Waiting...</span>)</h2>
            <div class="health-bar-container">
                <div id="player2HealthBar" class="health-bar" style="width: 100%;"></div>
            </div>
            <p class="text-lg text-center">Health: <span id="player2Health">10</span></p>
            <p class="text-lg text-center">Coins: <span id="player2Coins">0</span></p>
            <p class="text-lg text-center">Defense: <span id="player2Defense">0</span></p>

            <h3 class="text-xl font-semibold mt-4 text-center">Draw Your Character:</h3>
            <canvas id="player2Canvas" width="300" height="300" class="mx-auto"></canvas>
            <button id="player2ClearBtn" class="btn btn-danger mt-2">Clear Drawing</button>
            <button id="player2ConfirmDrawingBtn" class="btn btn-primary mt-2">Confirm Drawing</button>

            <h3 class="text-xl font-semibold mt-4 text-center">Rock Paper Scissors:</h3>
            <div class="flex justify-center gap-3 mt-2">
                <button id="player2RockBtn" class="rps-gif-btn rps-btn" data-player="2" data-choice="rock">
                    <img src="https://editablegifs.com/gifs/gifs/rock-paper-scissors-2/thumbnail.gif" alt="Rock GIF" onerror="this.onerror=null;this.src='https://placehold.co/60x60/63b3ed/FFFFFF?text=ROCK';">
                    <span>Rock</span>
                </button>
                <button id="player2PaperBtn" class="rps-gif-btn rps-btn" data-player="2" data-choice="paper">
                    <img src="https://editablegifs.com/gifs/gifs/rock-paper-scissors-3/thumbnail.gif" alt="Paper GIF" onerror="this.onerror=null;this.src='https://placehold.co/60x60/63b3ed/FFFFFF?text=PAPER';">
                    <span>Paper</span>
                </button>
                <button id="player2ScissorsBtn" class="rps-gif-btn rps-btn" data-player="2" data-choice="scissors">
                    <img src="https://editablegifs.com/gifs/gifs/rock-paper-scissors-4/thumbnail.gif" alt="Scissors GIF" onerror="this.onerror=null;this.src='https://placehold.co/60x60/63b3ed/FFFFFF?text=SCISSORS';">
                    <span>Scissors</span>
                </button>
            </div>

            <h3 class="text-xl font-semibold mt-4 text-center">Actions:</h3>
            <div class="flex flex-col gap-3 mt-2">
                <button id="player2DefendBtn" class="btn btn-success action-btn" data-player="2">Defend (+1 Health, -1 Coin)</button>
                <button id="player2AttackBtn" class="btn btn-warning action-btn" data-player="2">Attack Opponent</button>
                <button id="player2BuyWeaponBtn" class="btn btn-primary action-btn" data-player="2">Buy Weapon</button>
            </div>

            <h3 class="text-xl font-semibold mt-4 text-center">Your Weapons:</h3>
            <ul id="player2WeaponsList" class="flex flex-col gap-2 mt-2">
                </ul>
        </div>
    </div>

    <div id="gameMessageBox" class="message-box fixed bottom-5 left-1/2 -translate-x-1/2 w-11/12 md:w-1/2 z-50 hidden">
        <p id="gameMessageText" class=""></p>
        <button id="gameMessageCloseBtn" class="btn btn-primary mt-3 mx-auto">OK</button>
    </div>

    <div id="gameModal" class="modal hidden">
        <div class="modal-content">
            <span class="modal-close-btn" id="modalCloseBtn">&times;</span>
            <h3 id="modalTitle" class="text-2xl font-bold text-blue-300 mb-4"></h3>
            <div id="modalBody" class="flex flex-col gap-3">
                </div>
            <div id="modalButtons" class="modal-buttons">
                </div>
        </div>
    </div>

    <script type="module">
        // Firebase imports
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc, onSnapshot, collection, query, where, addDoc, getDocs, deleteDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";


        // --- DOM Elements (Moved to top for immediate access) ---
        // These are declared here so they are available immediately when the module script runs.
        const lobbySection = document.getElementById('lobbySection');
        const gameIdInput = document.getElementById('gameIdInput');
        const joinGameBtn = document.getElementById('joinGameBtn');
        const createGameBtn = document.getElementById('createGameBtn');
        const findMatchBtn = document.getElementById('findMatchBtn'); // New matchmaking button
        const cancelMatchmakingBtn = document.getElementById('cancelMatchmakingBtn'); // New cancel matchmaking button
        const lobbyMessage = document.getElementById('lobbyMessage');
        const gameContainer = document.getElementById('gameContainer');

        const player1Canvas = document.getElementById('player1Canvas');
        const player1Ctx = player1Canvas.getContext('2d');
        const player1ClearBtn = document.getElementById('player1ClearBtn');
        const player1ConfirmDrawingBtn = document.getElementById('player1ConfirmDrawingBtn'); // New confirm drawing button
        const player1HealthBar = document.getElementById('player1HealthBar');
        const player1HealthText = document.getElementById('player1Health');
        const player1CoinsText = document.getElementById('player1Coins'); // Renamed from player1Wins
        const player1DefenseText = document.getElementById('player1Defense');
        const player1WeaponsList = document.getElementById('player1WeaponsList');
        const player1Status = document.getElementById('player1Status');

        const player2Canvas = document.getElementById('player2Canvas');
        const player2Ctx = player2Canvas.getContext('2d');
        const player2ClearBtn = document.getElementById('player2ClearBtn');
        const player2ConfirmDrawingBtn = document.getElementById('player2ConfirmDrawingBtn'); // New confirm drawing button
        const player2HealthBar = document.getElementById('player2HealthBar');
        const player2HealthText = document.getElementById('player2Health');
        const player2CoinsText = document.getElementById('player2Coins'); // Renamed from player2Wins
        const player2DefenseText = document.getElementById('player2Defense');
        const player2WeaponsList = document.getElementById('player2WeaponsList');
        const player2Status = document.getElementById('player2Status');

        // Select both text and GIF RPS buttons
        const rpsButtons = document.querySelectorAll('.rps-btn');
        const actionButtons = document.querySelectorAll('.action-btn');

        const gameMessageBox = document.getElementById('gameMessageBox');
        const gameMessageText = document.getElementById('gameMessageText');
        const gameMessageCloseBtn = document.getElementById('gameMessageCloseBtn');

        const gameModal = document.getElementById('gameModal');
        const modalCloseBtn = document.getElementById('modalCloseBtn');
        const modalTitle = document.getElementById('modalTitle');
        const modalBody = document.getElementById('modalBody');
        const modalButtons = document.getElementById('modalButtons');


        // --- Firebase Configuration & Initialization ---
        // IMPORTANT: REPLACE THESE PLACEHOLDER VALUES WITH YOUR OWN FIREBASE CONFIGURATION!
        // 1. Go to Firebase Console (console.firebase.google.com).
        // 2. Select your project or create a new one.
        // 3. In the left navigation, click "Project settings" (gear icon).
        // 4. Under "Your apps," click the web icon (</>) to "Add app to get started" or select an existing web app.
        // 5. Copy the `firebaseConfig` object provided and paste it below.
        // 6. Also, ensure "Anonymous" authentication is enabled under "Authentication" -> "Sign-in method" in Firebase.
        const firebaseConfig = {
            apiKey: "AIzaSyDtQHjF5vwE27v4XgjMeCfjTPZPdJNAdtc",
            authDomain: "rock-paper-scissors-83923.firebaseapp.com",
            projectId: "rock-paper-scissors-83923",
            storageBucket: "rock-paper-scissors-83923.firebasestorage.app",
            messagingSenderId: "773167875394",
            appId: "1:773167875394:web:172cf11abc788b8efe74db",
            measurementId: "G-NNMXQBVVLC" // This line is specific to analytics and can be removed if not used.
        };

        // This appId will be used for your Firestore collection path.
        // You can choose any unique string for your game, e.g., 'rps-drawing-game-v1'
        const appId = 'rps-drawing-game-v1';


        let app;
        let db;
        let auth;
        let currentUserId = null;
        let gameRef = null; // Reference to the current game document in Firestore
        let unsubscribeGameListener = null; // To stop listening to game updates
        let unsubscribeMatchmakingListener = null; // To stop listening to matchmaking queue

        // Game state variables
        const initialHealth = 10;
        let players = {
            player1: {
                health: initialHealth,
                coins: 0, // Renamed from wins
                defense: 0,
                weapons: [],
                drawingDataURL: '', // Stores the base64 image of the drawing
                drawingConfirmed: false, // New field for drawing confirmation
                lastRPSChoice: null,
                userId: null // Firebase UID of player 1
            },
            player2: {
                health: initialHealth,
                coins: 0, // Renamed from wins
                defense: 0,
                weapons: [],
                drawingDataURL: '',
                drawingConfirmed: false, // New field for drawing confirmation
                lastRPSChoice: null,
                userId: null // Firebase UID of player 2
            }
        };

        // Weapon definitions
        const weapons = [
            { name: "Laser", cost: 1, damage: 1 },
            { name: "Pistol", cost: 2, damage: 3 },
            { name: "Gun", cost: 3, damage: 5 },
            { name: "Shotgun", cost: 4, damage: 7 },
            { name: "Grenade", cost: 5, damage: 9 }
        ];

        let gamePhase = 'lobby'; // 'lobby', 'drawing', 'rps', 'action_choice', 'game_over'
        let currentPlayerTurn = null; // Which player's UID is currently making an RPS choice or action choice
        let rpsChoices = { player1: null, player2: null }; // Stores 'rock', 'paper', 'scissors'
        let winnerOfRPS = null; // Stores UID of RPS winner


        let myPlayerId = null; // 'player1' or 'player2' for the current user
        let opponentPlayerId = null; // 'player1' or 'player2' for the opponent


        // --- Utility Functions ---

        /**
         * Displays a message box to the user.
         * @param {string} message The message to display.
         * @param {function} [callback] An optional callback function to execute when the message box is closed.
         */
        function showMessageBox(message, callback = null) {
            gameMessageText.textContent = message;
            gameMessageBox.classList.remove('hidden');
            gameMessageCloseBtn.onclick = () => {
                gameMessageBox.classList.add('hidden');
                if (callback) {
                    callback();
                }
            };
        }

        /**
         * Shows a generic modal with custom content and buttons.
         * @param {string} title The title of the modal.
         * @param {string} bodyHtml The HTML content for the modal body.
         * @param {Array<Object>} buttons An array of button objects: [{ text: 'Button Text', class: 'btn-primary', onClick: function }]
         * @param {boolean} [closable=true] Whether the modal can be closed by clicking the 'x' button.
         */
        function showModal(title, bodyHtml, buttons, closable = true) {
            modalTitle.textContent = title;
            modalBody.innerHTML = bodyHtml;
            modalButtons.innerHTML = ''; // Clear previous buttons

            buttons.forEach(btnConfig => {
                const button = document.createElement('button');
                button.textContent = btnConfig.text;
                button.className = `btn ${btnConfig.class || 'btn-primary'}`;
                button.onclick = () => {
                    hideModal(); // Hide modal before executing button's action
                    if (btnConfig.onClick) {
                        btnConfig.onClick();
                    }
                };
                modalButtons.appendChild(button);
            });

            if (closable) {
                modalCloseBtn.classList.remove('hidden');
                modalCloseBtn.onclick = hideModal;
            } else {
                modalCloseBtn.classList.add('hidden');
            }
            gameModal.classList.remove('hidden');
        }

        /**
         * Hides the currently active modal.
         */
        function hideModal() {
            gameModal.classList.add('hidden');
        }

        /**
         * Updates the UI elements for a specific player.
         * @param {string} playerId 'player1' or 'player2'.
         */
        function updatePlayerUI(playerId) {
            const player = players[playerId];
            const healthBar = document.getElementById(`${playerId}HealthBar`);
            const healthText = document.getElementById(`${playerId}Health`);
            const coinsText = document.getElementById(`${playerId}Coins`); // Renamed from winsText
            const defenseText = document.getElementById(`${playerId}Defense`);
            const weaponsList = document.getElementById(`${playerId}WeaponsList`);
            const playerStatus = document.getElementById(`${playerId}Status`);
            const confirmDrawingBtn = document.getElementById(`${playerId}ConfirmDrawingBtn`);


            healthText.textContent = player.health;
            healthBar.style.width = `${(player.health / initialHealth) * 100}%`;
            healthBar.style.backgroundColor = player.health > initialHealth / 2 ? '#48bb78' : (player.health > initialHealth / 4 ? '#ecc94b' : '#e53e3e');

            coinsText.textContent = player.coins; // Updated to coins
            defenseText.textContent = player.defense;

            // Update player status (e.g., "You", "Opponent", "Waiting...")
            if (player.userId === currentUserId) {
                playerStatus.textContent = 'You';
                playerStatus.classList.remove('text-red-300');
                playerStatus.classList.add('text-green-300');
            } else if (player.userId) {
                playerStatus.textContent = 'Opponent';
                playerStatus.classList.remove('text-green-300');
                playerStatus.classList.add('text-red-300');
            } else {
                playerStatus.textContent = 'Waiting...';
                playerStatus.classList.remove('text-green-300', 'text-red-300');
            }

            // Update weapons list
            weaponsList.innerHTML = '';
            if (player.weapons.length === 0) {
                const li = document.createElement('li');
                li.textContent = 'No weapons owned.';
                li.className = 'text-center text-gray-400';
                weaponsList.appendChild(li);
            } else {
                player.weapons.forEach(weapon => {
                    const li = document.createElement('li');
                    li.className = 'weapon-item owned';
                    li.innerHTML = `<span>${weapon.name}</span> <span>Damage: ${weapon.damage}</span>`;
                    weaponsList.appendChild(li);
                });
            }

            // Update confirm drawing button state
            if (player.userId === currentUserId && !player.drawingConfirmed && gamePhase === 'drawing') {
                confirmDrawingBtn.classList.remove('btn-disabled');
                confirmDrawingBtn.disabled = false;
            } else {
                confirmDrawingBtn.classList.add('btn-disabled');
                confirmDrawingBtn.disabled = true;
            }
        }

        /**
         * Disables or enables a set of buttons.
         * @param {NodeListOf<Element>} buttons The NodeList of buttons to modify.
         * @param {boolean} isDisabled True to disable, false to enable.
         */
        function setButtonsDisabled(buttons, isDisabled) {
            buttons.forEach(button => {
                button.disabled = isDisabled;
                if (isDisabled) {
                    button.classList.add('btn-disabled');
                    // For RPS buttons, remove the specific blue background
                    if (button.classList.contains('rps-gif-btn')) {
                        button.style.backgroundColor = ''; // Reset to default gray from btn-disabled
                    } else {
                        button.classList.remove('btn-primary', 'btn-success', 'btn-danger', 'btn-warning');
                    }
                } else {
                    button.classList.remove('btn-disabled');
                    // Restore original button styles based on their data attributes or default
                    if (button.classList.contains('rps-gif-btn')) {
                         button.style.backgroundColor = '#63b3ed'; // Restore blue for RPS buttons
                    } else if (button.classList.contains('rps-btn')) { // Fallback for old rps buttons if any
                         button.classList.add('btn-primary');
                    } else if (button.id.includes('DefendBtn')) {
                        button.classList.add('btn-success');
                    } else if (button.id.includes('AttackBtn')) {
                        button.classList.add('btn-warning');
                    } else if (button.id.includes('BuyWeaponBtn')) {
                        button.classList.add('btn-primary');
                    } else if (button.id.includes('ClearBtn')) {
                        button.classList.add('btn-danger');
                    } else if (button.id.includes('ConfirmDrawingBtn')) { // For the new confirm button
                        button.classList.add('btn-primary');
                    }
                }
            });
        }

        /**
         * Manages button states based on the current game phase and player turn.
         */
        function updateButtonStates() {
            // Disable all RPS and action buttons initially
            setButtonsDisabled(rpsButtons, true);
            setButtonsDisabled(actionButtons, true);

            // Enable clear buttons always
            setButtonsDisabled(document.querySelectorAll('[id$="ClearBtn"]'), false);

            // Ensure myPlayerId and opponentPlayerId are set before trying to access sections
            if (!myPlayerId || !opponentPlayerId) {
                // This can happen briefly during initialization or if only one player is connected.
                // We'll just keep buttons disabled until both players are assigned.
                return;
            }

            const myPlayerSection = document.getElementById(`${myPlayerId}Section`);
            const opponentPlayerSection = document.getElementById(`${opponentPlayerId}Section`);

            // Handle confirm drawing button separately
            const myConfirmDrawingBtn = document.getElementById(`${myPlayerId}ConfirmDrawingBtn`);
            const opponentConfirmDrawingBtn = document.getElementById(`${opponentPlayerId}ConfirmDrawingBtn`);

            if (gamePhase === 'drawing') {
                // Only enable confirm drawing for the current user if they haven't confirmed yet
                if (players[myPlayerId].userId === currentUserId && !players[myPlayerId].drawingConfirmed) {
                    setButtonsDisabled([myConfirmDrawingBtn], false);
                } else {
                    setButtonsDisabled([myConfirmDrawingBtn], true);
                }
                setButtonsDisabled([opponentConfirmDrawingBtn], true); // Opponent's button always disabled for current user
            } else if (gamePhase === 'rps') {
                // Disable confirm drawing buttons once in RPS phase
                setButtonsDisabled([myConfirmDrawingBtn, opponentConfirmDrawingBtn], true);

                if (currentPlayerTurn === currentUserId) {
                    setButtonsDisabled(myPlayerSection.querySelectorAll('.rps-btn'), false);
                    setButtonsDisabled(opponentPlayerSection.querySelectorAll('.rps-btn'), true);
                } else {
                    setButtonsDisabled(myPlayerSection.querySelectorAll('.rps-btn'), true);
                    setButtonsDisabled(opponentPlayerSection.querySelectorAll('.rps-btn'), true);
                }
            } else if (gamePhase === 'action_choice') {
                // Disable confirm drawing buttons
                setButtonsDisabled([myConfirmDrawingBtn, opponentConfirmDrawingBtn], true);

                if (winnerOfRPS === currentUserId) {
                    setButtonsDisabled(myPlayerSection.querySelectorAll('.action-btn'), false);
                    setButtonsDisabled(opponentPlayerSection.querySelectorAll('.action-btn'), true);
                } else {
                    setButtonsDisabled(myPlayerSection.querySelectorAll('.action-btn'), true);
                    setButtonsDisabled(opponentPlayerSection.querySelectorAll('.action-btn'), true);
                }
            } else if (gamePhase === 'game_over') {
                // All buttons remain disabled
                setButtonsDisabled([myConfirmDrawingBtn, opponentConfirmDrawingBtn], true);
            }
        }

        // --- Drawing Logic ---
        /**
         * Sets up drawing functionality for a given canvas.
         * @param {HTMLCanvasElement} canvas The canvas element.
         * @param {CanvasRenderingContext2D} ctx The 2D rendering context of the canvas.
         * @param {string} playerId 'player1' or 'player2'.
         */
        function setupDrawing(canvas, ctx, playerId) {
            let isDrawing = false;
            let lastX = 0;
            let lastY = 0;

            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#000000'; // Black drawing color

            function getCoords(e) {
                const rect = canvas.getBoundingClientRect();
                if (e.touches && e.touches.length > 0) {
                    return {
                        x: e.touches[0].clientX - rect.left,
                        y: e.touches[0].clientY - rect.top
                    };
                }
                return {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            }

            function startDrawing(e) {
                // Only allow drawing if it's your canvas and game is in drawing phase AND drawing is not confirmed
                if (gamePhase !== 'drawing' || players[playerId].userId !== currentUserId || players[playerId].drawingConfirmed) return;
                isDrawing = true;
                const coords = getCoords(e);
                [lastX, lastY] = [coords.x, coords.y];
            }

            function draw(e) {
                if (!isDrawing) return;
                const coords = getCoords(e);
                ctx.beginPath();
                ctx.moveTo(lastX, lastY);
                ctx.lineTo(coords.x, coords.y);
                ctx.stroke();
                [lastX, lastY] = [coords.x, coords.y];
            }

            function stopDrawing() {
                if (isDrawing) {
                    isDrawing = false;
                    // Save drawing to Firestore after drawing is stopped
                    saveDrawingToFirestore(playerId, canvas.toDataURL());
                }
            }

            // Mouse events
            canvas.addEventListener('mousedown', startDrawing);
            canvas.addEventListener('mousemove', draw);
            canvas.addEventListener('mouseup', stopDrawing);
            canvas.addEventListener('mouseout', stopDrawing);

            // Touch events
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // Prevent scrolling
                startDrawing(e);
            });
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault(); // Prevent scrolling
                draw(e);
            });
            canvas.addEventListener('touchend', stopDrawing);
            canvas.addEventListener('touchcancel', stopDrawing);
        }

        /**
         * Clears the drawing on a specified canvas.
         * @param {CanvasRenderingContext2D} ctx The 2D rendering context of the canvas.
         * @param {HTMLCanvasElement} canvas The canvas element.
         * @param {string} playerId 'player1' or 'player2'.
         */
        function clearCanvas(ctx, canvas, playerId) {
            if (players[playerId].userId !== currentUserId) {
                showMessageBox("You can only clear your own drawing!");
                return;
            }
            if (players[playerId].drawingConfirmed) {
                showMessageBox("You have already confirmed your drawing. Cannot clear.");
                return;
            }
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            saveDrawingToFirestore(playerId, ''); // Save empty drawing
        }

        /**
         * Saves the canvas drawing as a data URL to Firestore.
         * @param {string} playerId 'player1' or 'player2'.
         * @param {string} dataURL The base64 data URL of the canvas.
         */
        async function saveDrawingToFirestore(playerId, dataURL) {
            if (!gameRef) return;
            try {
                const updateData = {};
                updateData[`players.${playerId}.drawingDataURL`] = dataURL;
                await updateDoc(gameRef, updateData);
            } catch (error) {
                console.error("Error saving drawing to Firestore:", error);
            }
        }

        /**
         * Loads a drawing from a data URL onto a canvas.
         * @param {CanvasRenderingContext2D} ctx The 2D rendering context.
         * @param {HTMLCanvasElement} canvas The canvas element.
         * @param {string} dataURL The base64 data URL of the image.
         */
        function loadDrawingFromDataURL(ctx, canvas, dataURL) {
            ctx.clearRect(0, 0, canvas.width, canvas.height); // Clear before loading new drawing
            if (dataURL) {
                const img = new Image();
                img.onload = () => {
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                };
                img.src = dataURL;
            }
        }

        // Setup drawing for both players
        setupDrawing(player1Canvas, player1Ctx, 'player1');
        setupDrawing(player2Canvas, player2Ctx, 'player2');

        // Clear button event listeners
        player1ClearBtn.addEventListener('click', () => clearCanvas(player1Ctx, player1Canvas, 'player1'));
        player2ClearBtn.addEventListener('click', () => clearCanvas(player2Ctx, player2Canvas, 'player2'));

        // --- Game Logic ---

        /**
         * Initializes or resets the game state in Firestore.
         * This function should only be called by the player creating the game.
         * @param {string} gameId The ID of the game to initialize.
         * @param {string} creatorUid The UID of the player creating the game.
         */
        async function initializeGameState(gameId, creatorUid) {
            if (!db) {
                showMessageBox("Firebase is not initialized. Cannot create game.");
                return;
            }
            const initialGameState = {
                gamePhase: 'drawing',
                players: {
                    player1: {
                        health: initialHealth,
                        coins: 0, // Renamed from wins
                        defense: 0,
                        weapons: [],
                        drawingDataURL: '',
                        drawingConfirmed: false, // New field for drawing confirmation
                        lastRPSChoice: null,
                        userId: creatorUid
                    },
                    player2: {
                        health: initialHealth,
                        coins: 0, // Renamed from wins
                        defense: 0,
                        weapons: [],
                        drawingDataURL: '',
                        drawingConfirmed: false, // New field for drawing confirmation
                        lastRPSChoice: null,
                        userId: null // Waiting for player 2
                    }
                },
                currentPlayerTurn: creatorUid, // Player 1 starts RPS (after drawing)
                rpsChoices: { player1: null, player2: null },
                winnerOfRPS: null,
                lastActionMessage: `Welcome! Player 1 (${creatorUid.substring(0, 6)}...) has created the game. Waiting for Player 2 to join.`,
                createdAt: new Date().toISOString()
            };

            gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
            try {
                await setDoc(gameRef, initialGameState);
                console.log("Game initialized in Firestore with ID:", gameId);
                lobbyMessage.textContent = `Game created! Share this ID: ${gameId}`;
                lobbyMessage.classList.remove('text-red-400');
                lobbyMessage.classList.add('text-green-400');
                startGameListener(gameId);
            } catch (error) {
                console.error("Error creating game in Firestore:", error);
                showMessageBox(`Failed to create game: ${error.message}. Check Firebase rules and permissions.`);
                lobbyMessage.textContent = `Failed to create game: ${error.message}.`;
                lobbyMessage.classList.add('text-red-400');
            }
        }

        /**
         * Joins an existing game.
         * @param {string} gameId The ID of the game to join.
         * @param {string} joinerUid The UID of the player joining.
         */
        async function joinGame(gameId, joinerUid) {
            if (!db) {
                showMessageBox("Firebase is not initialized. Cannot join game.");
                return;
            }
            gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
            try {
                const gameDoc = await getDoc(gameRef);

                if (!gameDoc.exists()) {
                    lobbyMessage.textContent = "Game not found. Please check the ID or create a new game.";
                    return;
                }

                const gameData = gameDoc.data();

                if (gameData.players.player1.userId === joinerUid || gameData.players.player2.userId === joinerUid) {
                    lobbyMessage.textContent = "You are already in this game!";
                    startGameListener(gameId); // Re-join listener
                    return;
                }
                
                if (gameData.players.player1.userId && gameData.players.player2.userId) {
                    lobbyMessage.textContent = "This game is full.";
                    return;
                }

                let playerToAssign = null;
                if (!gameData.players.player1.userId) {
                    playerToAssign = 'player1';
                } else if (!gameData.players.player2.userId) {
                    playerToAssign = 'player2';
                }

                if (playerToAssign) {
                    const updateData = {};
                    updateData[`players.${playerToAssign}.userId`] = joinerUid;
                    updateData.lastActionMessage = `${joinerUid.substring(0, 6)}... has joined the game!`;
                    await updateDoc(gameRef, updateData);
                    lobbyMessage.textContent = `Joined game ${gameId}!`;
                    lobbyMessage.classList.remove('text-red-400');
                    lobbyMessage.classList.add('text-green-400');
                    startGameListener(gameId);
                } else {
                    lobbyMessage.textContent = "Could not join game. Unexpected state.";
                }
            } catch (error) {
                console.error("Error joining game in Firestore:", error);
                showMessageBox(`Failed to join game: ${error.message}. Check Firebase rules and permissions.`);
                lobbyMessage.textContent = `Failed to join game: ${error.message}.`;
                lobbyMessage.classList.add('text-red-400');
            }
        }

        /**
         * Starts listening for real-time updates to the game document.
         * @param {string} gameId The ID of the game to listen to.
         */
        function startGameListener(gameId) {
            if (!db) {
                console.error("Firebase is not initialized. Cannot start game listener.");
                showMessageBox("Firebase is not initialized. Cannot start game listener.");
                return;
            }
            if (unsubscribeGameListener) {
                unsubscribeGameListener(); // Unsubscribe from previous listener if any
            }

            gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', gameId);
            unsubscribeGameListener = onSnapshot(gameRef, (docSnapshot) => {
                if (docSnapshot.exists()) {
                    const gameData = docSnapshot.data();
                    updateLocalGameState(gameData);
                } else {
                    showMessageBox("Game ended or deleted by host. Returning to lobby.", () => {
                        resetGame();
                        lobbySection.classList.remove('hidden');
                        gameContainer.classList.add('hidden');
                    });
                }
            }, (error) => {
                console.error("Error listening to game updates:", error);
                showMessageBox("Lost connection to the game. Please check your internet or try again.", () => {
                    resetGame();
                    lobbySection.classList.remove('hidden');
                    gameContainer.classList.add('hidden');
                });
            });

            lobbySection.classList.add('hidden');
            gameContainer.classList.remove('hidden');
            gameIdInput.value = gameId; // Display the game ID in the input
        }

        /**
         * Updates the local game state based on Firestore data.
         * @param {Object} gameData The game data from Firestore.
         */
        function updateLocalGameState(gameData) {
            // Update core game state
            gamePhase = gameData.gamePhase;
            currentPlayerTurn = gameData.currentPlayerTurn;
            rpsChoices = gameData.rpsChoices;
            winnerOfRPS = gameData.winnerOfRPS;

            // Update player data
            players.player1 = { ...players.player1, ...gameData.players.player1 };
            players.player2 = { ...players.player2, ...gameData.players.player2 };

            // Determine myPlayerId and opponentPlayerId
            if (players.player1.userId === currentUserId) {
                myPlayerId = 'player1';
                opponentPlayerId = 'player2';
            } else if (players.player2.userId === currentUserId) {
                myPlayerId = 'player2';
                opponentPlayerId = 'player1';
            } else {
                // This can happen if a third person is viewing or if initial assignment hasn't happened.
                // For now, we assume a player is either player1 or player2.
                myPlayerId = null;
                opponentPlayerId = null;
            }

            // Update UI
            updatePlayerUI('player1');
            updatePlayerUI('player2');

            // Load drawings
            loadDrawingFromDataURL(player1Ctx, player1Canvas, players.player1.drawingDataURL);
            loadDrawingFromDataURL(player2Ctx, player2Canvas, players.player2.drawingDataURL);

            // Display last action message
            if (gameData.lastActionMessage && gameMessageText.textContent !== gameData.lastActionMessage) {
                showMessageBox(gameData.lastActionMessage);
            }

            // Manage button states
            updateButtonStates();

            // Check if game is ready to start (both players joined and drawings confirmed)
            // This logic is now handled by handleConfirmDrawing
            if (gamePhase === 'drawing' && players.player1.userId && players.player2.userId && !players.player1.drawingConfirmed && !players.player2.drawingConfirmed) {
                // If both players are in the drawing phase and haven't confirmed, prompt them
                // This message would ideally be shown once or as a reminder.
                // The actual phase transition happens when both confirm their drawing.
            }


            // Handle game over state locally
            if (gamePhase === 'game_over') {
                // The message box for game over is triggered by checkGameOver() when health drops.
                // If we receive a game_over state from Firestore, ensure the UI reflects it.
                updateButtonStates(); // Disable all buttons
            }
        }


        /**
         * Updates the game state in Firestore.
         * @param {Object} updates An object containing the fields to update.
         */
        async function updateGameState(updates) {
            if (!gameRef) {
                console.error("No active game reference to update.");
                showMessageBox("Error: Not connected to a game. Please create or join one.");
                return;
            }
            try {
                await updateDoc(gameRef, updates);
            } catch (error) {
                console.error("Error updating game state:", error);
                showMessageBox("Failed to update game state. Please try again.");
            }
        }

        /**
         * Handles a player's RPS choice.
         * @param {string} playerId 'player1' or 'player2'.
         * @param {string} choice 'rock', 'paper', or 'scissors'.
         */
        async function handleRPSChoice(playerId, choice) {
            if (gamePhase !== 'rps' || players[playerId].userId !== currentUserId) {
                showMessageBox("It's not your turn or the wrong phase for RPS.");
                return;
            }

            // Prevent double-choice or out-of-turn choice
            if (rpsChoices[playerId] !== null) {
                showMessageBox("You have already made your choice for this round.");
                return;
            }
            if (currentPlayerTurn !== currentUserId) {
                showMessageBox("It's not your turn to choose RPS.");
                return;
            }

            const newRpsChoices = { ...rpsChoices, [playerId]: choice };
            const newLastRPSChoice = choice;

            let updates = {
                [`players.${playerId}.lastRPSChoice`]: newLastRPSChoice,
                [`rpsChoices.${playerId}`]: newRpsChoices[playerId],
            };

            if (newRpsChoices.player1 && newRpsChoices.player2) {
                // Both players have chosen, determine winner
                const p1Choice = newRpsChoices.player1;
                const p2Choice = newRpsChoices.player2;
                let message = `Player 1 chose ${p1Choice}, Player 2 chose ${p2Choice}. `;
                let newWinnerOfRPS = null;
                let player1Coins = players.player1.coins;
                let player2Coins = players.player2.coins;

                if (p1Choice === p2Choice) {
                    // It's a tie! Reset for a new RPS round.
                    message += "It's a tie! No one wins this round. Starting a new RPS round.";
                    updates.gamePhase = 'rps';
                    updates.rpsChoices = { player1: null, player2: null };
                    updates.currentPlayerTurn = players.player1.userId;
                    updates.lastActionMessage = message;
                } else if (
                    (p1Choice === 'rock' && p2Choice === 'scissors') ||
                    (p1Choice === 'paper' && p2Choice === 'rock') ||
                    (p1Choice === 'scissors' && p2Choice === 'paper')
                ) {
                    // Player 1 wins
                    newWinnerOfRPS = players.player1.userId;
                    player1Coins++;
                    message += `${players.player1.userId.substring(0, 6)}... wins the RPS round! They can now choose an action.`;
                    updates.gamePhase = 'action_choice';
                    updates.winnerOfRPS = newWinnerOfRPS;
                    updates[`players.player1.coins`] = player1Coins;
                    updates.rpsChoices = { player1: null, player2: null };
                    updates.currentPlayerTurn = newWinnerOfRPS;
                    updates.lastActionMessage = message;
                } else {
                    // Player 2 wins
                    newWinnerOfRPS = players.player2.userId;
                    player2Coins++;
                    message += `${players.player2.userId.substring(0, 6)}... wins the RPS round! They can now choose an action.`;
                    updates.gamePhase = 'action_choice';
                    updates.winnerOfRPS = newWinnerOfRPS;
                    updates[`players.player2.coins`] = player2Coins;
                    updates.rpsChoices = { player1: null, player2: null };
                    updates.currentPlayerTurn = newWinnerOfRPS;
                    updates.lastActionMessage = message;
                }
            } else {
                // Only one player has chosen, switch turn
                updates.currentPlayerTurn = (players.player1.userId === currentUserId) ? players.player2.userId : players.player1.userId;
                updates.lastActionMessage = `${players[playerId].userId.substring(0, 6)}... has chosen. Waiting for opponent.`;
            }

            await updateGameState(updates);
        }

        /**
         * Handles the winner's chosen action.
         * @param {string} action 'defend', 'attack', or 'buy_weapon'.
         */
        async function handleActionChoice(action) {
            if (gamePhase !== 'action_choice' || winnerOfRPS !== currentUserId) {
                showMessageBox("It's not your turn or the wrong phase for action.");
                return;
            }

            const winnerPlayerId = myPlayerId; // The current user is the winner
            const winnerPlayer = players[winnerPlayerId];
            const opponentPlayerId = (winnerPlayerId === 'player1' ? 'player2' : 'player1');
            const opponentPlayer = players[opponentPlayerId];

            let updates = {};
            let message = "";
            let proceedToNextRound = true;

            switch (action) {
                case 'defend':
                    if (winnerPlayer.coins < 1) {
                        showMessageBox("You need at least 1 coin to defend!");
                        proceedToNextRound = false;
                        return;
                    }
                    updates[`players.${winnerPlayerId}.health`] = winnerPlayer.health + 1; // +1 Health
                    updates[`players.${winnerPlayerId}.coins`] = winnerPlayer.coins - 1; // -1 Coin
                    message = `${winnerPlayerId === 'player1' ? 'Player 1' : 'Player 2'} chose to defend, gaining 1 health and spending 1 coin!`;
                    break;
                case 'attack':
                    if (winnerPlayer.weapons.length === 0) {
                        showMessageBox("You have no weapons to attack with! Choose another action or buy a weapon.");
                        proceedToNextRound = false; // Stay in action_choice phase
                        return;
                    }
                    showWeaponSelectionModal(winnerPlayerId);
                    proceedToNextRound = false; // Wait for weapon selection
                    break;
                case 'buy_weapon':
                    showWeaponShopModal(winnerPlayerId);
                    proceedToNextRound = false; // Wait for weapon purchase
                    break;
            }

            if (proceedToNextRound) {
                updates.lastActionMessage = message;
                updates.gamePhase = 'rps'; // Move to next RPS round
                updates.currentPlayerTurn = players.player1.userId; // Player 1 starts next RPS
                updates[`players.player1.defense`] = 0; // Reset defenses
                updates[`players.player2.defense`] = 0; // Reset defenses
                await updateGameState(updates);
                checkGameOver(); // Check game over after health update
            } else if (action !== 'attack' && action !== 'buy_weapon') {
               // If an action was taken but not attack/buy, update state and check game over
                updates.lastActionMessage = message;
                await updateGameState(updates);
                checkGameOver();
            }
        }

        /**
         * Displays the weapon shop modal.
         * @param {string} playerId The ID of the player who is buying the weapon.
         */
        function showWeaponShopModal(playerId) {
            const player = players[playerId];
            let bodyHtml = `<p class="text-center text-lg mb-4">Your Coins: ${player.coins}</p>`; // Updated to Coins
            bodyHtml += `<ul class="flex flex-col gap-2">`;
            weapons.forEach(weapon => {
                const canAfford = player.coins >= weapon.cost; // Updated to coins
                const owned = player.weapons.some(w => w.name === weapon.name);
                bodyHtml += `
                    <li class="weapon-item ${owned ? 'owned' : ''} ${!canAfford && !owned ? 'opacity-50' : ''}">
                        <span>${weapon.name} (Cost: ${weapon.cost} Coins, Damage: ${weapon.damage})</span>
                        <button class="btn ${canAfford && !owned ? 'btn-success' : 'btn-disabled'}"
                                ${!canAfford || owned ? 'disabled' : ''}
                                onclick="window.buyWeapon('${playerId}', '${weapon.name}')">
                            ${owned ? 'Owned' : 'Buy'}
                        </button>
                    </li>
                `;
            });
            bodyHtml += `</ul>`;

            showModal("Weapon Shop", bodyHtml, [
                { text: 'Close', class: 'btn-primary', onClick: async () => {
                    // After closing, proceed to next round if no weapon was bought
                    await updateGameState({
                        lastActionMessage: "Weapon shop closed. Starting next RPS round.",
                        gamePhase: 'rps',
                        currentPlayerTurn: players.player1.userId,
                        [`players.player1.defense`]: 0, // Reset defenses
                        [`players.player2.defense`]: 0  // Reset defenses
                    });
                    checkGameOver();
                }}
            ], false); // Not closable by 'x' button, must choose an action
        }

        /**
         * Handles the purchase of a weapon.
         * @param {string} playerId 'player1' or 'player2'.
         * @param {string} weaponName The name of the weapon to buy.
         */
        window.buyWeapon = async function(playerId, weaponName) { // Made global for onclick
            const player = players[playerId];
            const weapon = weapons.find(w => w.name === weaponName);

            if (!weapon) {
                showMessageBox("Invalid weapon selected.");
                return;
            }
            if (player.coins < weapon.cost) { // Updated to coins
                showMessageBox("Not enough coins to buy this weapon!");
                return;
            }
            if (player.weapons.some(w => w.name === weapon.name)) {
                showMessageBox("You already own this weapon!");
                return;
            }

            const updatedWeapons = [...player.weapons, weapon];
            const updatedCoins = player.coins - weapon.cost; // Updated to coins

            hideModal(); // Close weapon shop modal

            await updateGameState({
                [`players.${playerId}.coins`]: updatedCoins, // Updated to coins
                [`players.${playerId}.weapons`]: updatedWeapons,
                lastActionMessage: `${playerId === 'player1' ? 'Player 1' : 'Player 2'} bought a ${weapon.name}! Starting next RPS round.`,
                gamePhase: 'rps',
                currentPlayerTurn: players.player1.userId,
                [`players.player1.defense`]: 0, // Reset defenses
                [`players.player2.defense`]: 0  // Reset defenses
            });
            checkGameOver();
        }

        /**
         * Displays the weapon selection modal for attacking.
         * @param {string} attackerId The ID of the player who is attacking.
         */
        function showWeaponSelectionModal(attackerId) {
            const attacker = players[attackerId];
            let bodyHtml = `<p class="text-center text-lg mb-4">Select a weapon to attack:</p>`;
            bodyHtml += `<ul class="flex flex-col gap-2">`;
            if (attacker.weapons.length === 0) {
                bodyHtml += `<li class="text-center text-gray-400">You have no weapons!</li>`;
            } else {
                attacker.weapons.forEach(weapon => {
                    bodyHtml += `
                        <li class="weapon-item owned">
                            <span>${weapon.name} (Damage: ${weapon.damage})</span>
                            <button class="btn btn-warning"
                                    onclick="window.performAttack('${attackerId}', '${weapon.name}')">
                                Attack with ${weapon.name}
                            </button>
                        </li>
                    `;
                });
            }
            bodyHtml += `</ul>`;

            showModal("Select Weapon", bodyHtml, [
                { text: 'Cancel', class: 'btn-danger', onClick: () => {
                    showMessageBox("Attack cancelled. Please choose another action.");
                    // Re-enable action buttons for the winner to choose again (handled by updateButtonStates on next render)
                }}
            ], false); // Not closable by 'x' button, must choose an action or cancel
        }

        /**
         * Performs the attack using the selected weapon.
         * @param {string} attackerId 'player1' or 'player2'.
         * @param {string} weaponName The name of the weapon used.
         */
        window.performAttack = async function(attackerId, weaponName) { // Made global for onclick
            const attacker = players[attackerId];
            const defenderId = attackerId === 'player1' ? 'player2' : 'player1';
            const defender = players[defenderId];
            const weapon = attacker.weapons.find(w => w.name === weaponName);

            if (!weapon) {
                showMessageBox("Error: Weapon not found.");
                return;
            }

            let damageDealt = weapon.damage - defender.defense;
            if (damageDealt < 0) damageDealt = 0; // Cannot heal opponent

            const updatedDefenderHealth = defender.health - damageDealt;

            hideModal(); // Close weapon selection modal

            await updateGameState({
                [`players.${defenderId}.health`]: updatedDefenderHealth < 0 ? 0 : updatedDefenderHealth,
                lastActionMessage: `${attackerId === 'player1' ? 'Player 1' : 'Player 2'} attacked ${defenderId === 'player1' ? 'Player 1' : 'Player 2'} with ${weapon.name}, dealing ${damageDealt} damage!`,
                gamePhase: 'rps',
                currentPlayerTurn: players.player1.userId,
                [`players.player1.defense`]: 0, // Reset defenses
                [`players.player2.defense`]: 0 // Reset defenses
            });
            checkGameOver();
        }

        /**
         * Checks if the game is over and declares the winner.
         * This function should be called after any health update.
         */
        async function checkGameOver() {
            if (players.player1.health <= 0) {
                await updateGameState({
                    gamePhase: 'game_over',
                    lastActionMessage: `Player 1's health reached 0! Player 2 (${players.player2.userId.substring(0,6)}...) wins the game! Click OK to restart.`
                });
                showMessageBox("Game Over! Player 2 wins! Click OK to restart.", resetGame);
            } else if (players.player2.health <= 0) {
                await updateGameState({
                    gamePhase: 'game_over',
                    lastActionMessage: `Player 2's health reached 0! Player 1 (${players.player1.userId.substring(0,6)}...) wins the game! Click OK to restart.`
                });
                showMessageBox("Game Over! Player 1 wins! Click OK to restart.", resetGame);
            }
        }

        /**
         * Resets the game to the lobby state.
         */
        async function resetGame() {
            if (unsubscribeGameListener) {
                unsubscribeGameListener();
                unsubscribeGameListener = null;
            }
            if (unsubscribeMatchmakingListener) { // Unsubscribe from matchmaking if active
                unsubscribeMatchmakingListener();
                unsubscribeMatchmakingListener = null;
            }
            gameRef = null;
            myPlayerId = null;
            opponentPlayerId = null;
            gamePhase = 'lobby';
            currentPlayerTurn = null;
            rpsChoices = { player1: null, player2: null };
            winnerOfRPS = null;

            // Reset local player states
            players.player1 = { health: initialHealth, coins: 0, defense: 0, weapons: [], drawingDataURL: '', drawingConfirmed: false, lastRPSChoice: null, userId: null };
            players.player2 = { health: initialHealth, coins: 0, defense: 0, weapons: [], drawingDataURL: '', drawingConfirmed: false, lastRPSChoice: null, userId: null };

            clearCanvas(player1Ctx, player1Canvas, 'player1');
            clearCanvas(player2Ctx, player2Canvas, 'player2');
            updatePlayerUI('player1');
            updatePlayerUI('player2');
            updateButtonStates();

            gameIdInput.value = '';
            lobbyMessage.textContent = '';
            lobbySection.classList.remove('hidden');
            gameContainer.classList.add('hidden');
            showMessageBox("Game has been reset. You can create or join a new game.");
            // Show matchmaking button again
            findMatchBtn.classList.remove('hidden');
            cancelMatchmakingBtn.classList.add('hidden');
        }

        // --- Matchmaking Logic ---
        let matchmakingQueueRef;
        let myQueueDocRef = null; // Reference to my entry in the queue

        /**
         * Initiates the matchmaking process.
         */
        async function findMatch() {
            if (!currentUserId) {
                showMessageBox("Please wait, authenticating with Firebase...");
                return;
            }
            if (!db) {
                showMessageBox("Firebase is not initialized. Cannot find match.");
                return;
            }

            lobbyMessage.textContent = 'Searching for opponent...';
            lobbyMessage.classList.remove('text-red-400');
            lobbyMessage.classList.add('text-yellow-400');
            findMatchBtn.classList.add('hidden');
            cancelMatchmakingBtn.classList.remove('hidden');

            matchmakingQueueRef = collection(db, 'artifacts', appId, 'public', 'data', 'matchmakingQueue');

            try {
                // Look for an existing player in the queue
                const q = query(matchmakingQueueRef, where('status', '==', 'waiting'), where('userId', '!=', currentUserId));
                const querySnapshot = await getDocs(q);

                if (!querySnapshot.empty) {
                    // An opponent is found!
                    const opponentDoc = querySnapshot.docs[0];
                    const opponentUserId = opponentDoc.data().userId;
                    const opponentDocRef = doc(matchmakingQueueRef, opponentDoc.id);

                    // Attempt to create a new game
                    const newGameId = crypto.randomUUID().substring(0, 8);
                    const initialGameState = {
                        gamePhase: 'drawing',
                        players: {
                            player1: {
                                health: initialHealth,
                                coins: 0,
                                defense: 0,
                                weapons: [],
                                drawingDataURL: '',
                                drawingConfirmed: false,
                                lastRPSChoice: null,
                                userId: currentUserId // Current user is player1
                            },
                            player2: {
                                health: initialHealth,
                                coins: 0,
                                defense: 0,
                                weapons: [],
                                drawingDataURL: '',
                                drawingConfirmed: false,
                                lastRPSChoice: null,
                                userId: opponentUserId // Opponent is player2
                            }
                        },
                        currentPlayerTurn: currentUserId,
                        rpsChoices: { player1: null, player2: null },
                        winnerOfRPS: null,
                        lastActionMessage: `Match found! ${currentUserId.substring(0, 6)}... vs ${opponentUserId.substring(0, 6)}...`,
                        createdAt: serverTimestamp()
                    };

                    gameRef = doc(db, 'artifacts', appId, 'public', 'data', 'games', newGameId);
                    await setDoc(gameRef, initialGameState);

                    // Update opponent's queue entry with the gameId and remove self from queue
                    await updateDoc(opponentDocRef, { status: 'matched', gameId: newGameId });
                    if (myQueueDocRef) { // If I was already in the queue, remove my old entry
                        await deleteDoc(myQueueDocRef);
                        myQueueDocRef = null;
                    }


                    showMessageBox(`Match found! Game ID: ${newGameId}. Starting game...`, () => {
                        startGameListener(newGameId);
                    });

                } else {
                    // No opponent found, add self to queue
                    myQueueDocRef = doc(matchmakingQueueRef, currentUserId); // Use UID as doc ID for easy management
                    await setDoc(myQueueDocRef, {
                        userId: currentUserId,
                        status: 'waiting',
                        timestamp: serverTimestamp()
                    });
                    lobbyMessage.textContent = 'Waiting for opponent...';

                    // Listen for changes to my own queue document to see if a game is assigned
                    unsubscribeMatchmakingListener = onSnapshot(myQueueDocRef, async (docSnapshot) => {
                        if (docSnapshot.exists()) {
                            const data = docSnapshot.data();
                            if (data.status === 'matched' && data.gameId) {
                                // I was matched by another player!
                                showMessageBox(`You were matched! Game ID: ${data.gameId}. Starting game...`, async () => {
                                    // Clean up my queue entry after joining the game
                                    await deleteDoc(myQueueDocRef);
                                    myQueueDocRef = null;
                                    startGameListener(data.gameId);
                                });
                                if (unsubscribeMatchmakingListener) {
                                    unsubscribeMatchmakingListener();
                                    unsubscribeMatchmakingListener = null;
                                }
                            }
                        } else {
                            // My queue entry was deleted, likely by another player matching with me
                            // This case is now handled by the 'matched' status check above.
                            // If doc doesn't exist, it means I was matched and my entry was cleaned up.
                            // The game listener should pick up the game state.
                            console.log("My queue entry deleted, expecting game to start via game listener.");
                            if (unsubscribeMatchmakingListener) {
                                unsubscribeMatchmakingListener();
                                unsubscribeMatchmakingListener = null;
                            }
                        }
                    });
                }
            } catch (error) {
                console.error("Error during matchmaking:", error);
                showMessageBox(`Matchmaking failed: ${error.message}. Please try again.`);
                lobbyMessage.textContent = `Matchmaking failed: ${error.message}.`;
                lobbyMessage.classList.add('text-red-400');
                cancelMatchmaking(); // Reset UI
            }
        }

        /**
         * Cancels the current matchmaking attempt.
         */
        async function cancelMatchmaking() {
            if (myQueueDocRef) {
                try {
                    await deleteDoc(myQueueDocRef);
                    myQueueDocRef = null;
                    showMessageBox("Matchmaking cancelled.");
                } catch (error) {
                    console.error("Error cancelling matchmaking:", error);
                    showMessageBox("Failed to cancel matchmaking. Please try again.");
                }
            }
            if (unsubscribeMatchmakingListener) {
                unsubscribeMatchmakingListener();
                unsubscribeMatchmakingListener = null;
            }
            lobbyMessage.textContent = '';
            findMatchBtn.classList.remove('hidden');
            cancelMatchmakingBtn.classList.add('hidden');
        }


        // --- Lobby Event Listeners ---
        createGameBtn.addEventListener('click', async () => {
            if (!currentUserId) {
                showMessageBox("Please wait, authenticating with Firebase...");
                return;
            }
            // Ensure Firebase is initialized before proceeding
            if (!app || !db || !auth) {
                showMessageBox("Firebase is not initialized. Please check your Firebase configuration.");
                return;
            }
            // Cancel matchmaking if active
            await cancelMatchmaking();
            lobbyMessage.textContent = 'Creating game...';
            lobbyMessage.classList.remove('text-red-400');
            lobbyMessage.classList.add('text-yellow-400');
            const newGameId = crypto.randomUUID().substring(0, 8); // Simple unique ID
            await initializeGameState(newGameId, currentUserId);
        });

        joinGameBtn.addEventListener('click', async () => {
            if (!currentUserId) {
                showMessageBox("Please wait, authenticating with Firebase...");
                return;
            }
            // Ensure Firebase is initialized before proceeding
            if (!app || !db || !auth) {
                showMessageBox("Firebase is not initialized. Please check your Firebase configuration.");
                return;
            }
            // Cancel matchmaking if active
            await cancelMatchmaking();
            const gameId = gameIdInput.value.trim();
            if (gameId) {
                lobbyMessage.textContent = 'Joining game...';
                lobbyMessage.classList.remove('text-red-400');
                lobbyMessage.classList.add('text-yellow-400');
                await joinGame(gameId, currentUserId);
            } else {
                lobbyMessage.textContent = "Please enter a Game ID.";
                lobbyMessage.classList.add('text-red-400');
            }
        });

        findMatchBtn.addEventListener('click', findMatch);
        cancelMatchmakingBtn.addEventListener('click', cancelMatchmaking);


        // --- Game Event Listeners ---

        // Confirm Drawing Buttons
        player1ConfirmDrawingBtn.addEventListener('click', () => handleConfirmDrawing('player1'));
        player2ConfirmDrawingBtn.addEventListener('click', () => handleConfirmDrawing('player2'));

        // Function to handle confirming drawing
        async function handleConfirmDrawing(playerId) {
            if (players[playerId].userId !== currentUserId) {
                showMessageBox("You can only confirm your own drawing!");
                return;
            }
            if (players[playerId].drawingConfirmed) {
                showMessageBox("Your drawing is already confirmed.");
                return;
            }

            // Update drawingConfirmed status in Firestore
            await updateGameState({
                [`players.${playerId}.drawingConfirmed`]: true,
                lastActionMessage: `${players[playerId].userId.substring(0, 6)}... has confirmed their drawing!`
            });

            // Check if both players have confirmed their drawing
            const gameDoc = await getDoc(gameRef);
            if (gameDoc.exists()) {
                const gameData = gameDoc.data();
                if (gameData.players.player1.drawingConfirmed && gameData.players.player2.drawingConfirmed) {
                    await updateGameState({
                        gamePhase: 'rps',
                        lastActionMessage: "Both players have confirmed their drawings! Time for Rock-Paper-Scissors. Player 1, make your choice."
                    });
                } else {
                    showMessageBox("Waiting for opponent to confirm their drawing...");
                }
            }
        }


        // RPS Buttons
        rpsButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                // Find the closest button with data-player and data-choice
                const targetButton = e.target.closest('.rps-btn');
                if (targetButton) {
                    const playerId = `player${targetButton.dataset.player}`;
                    const choice = targetButton.dataset.choice;
                    handleRPSChoice(playerId, choice);
                }
            });
        });

        // Action Buttons
        actionButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                const playerId = `player${e.target.dataset.player}`;
                // Ensure only the winner can click their action buttons
                if (players[playerId].userId !== winnerOfRPS) {
                    showMessageBox("It's not your turn to choose an action!");
                    return;
                }

                if (e.target.id.includes('Defend')) {
                    handleActionChoice('defend');
                } else if (e.target.id.includes('Attack')) {
                    handleActionChoice('attack');
                } else if (e.target.id.includes('BuyWeapon')) {
                    handleActionChoice('buy_weapon');
                }
            });
        });

        // Initial setup when page loads
        window.onload = () => {
            // Initialize Firebase and related logic here, ensuring DOM elements are ready.
            // Check if the placeholder config has been replaced
            if (firebaseConfig.apiKey && firebaseConfig.projectId && firebaseConfig.appId !== "YOUR_APP_ID") {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);

                onAuthStateChanged(auth, async (user) => {
                    if (user) {
                        currentUserId = user.uid;
                        document.getElementById('currentUserId').textContent = currentUserId;
                        console.log("Authenticated with Firebase. User ID:", currentUserId);
                    } else {
                        console.log("No user signed in. Attempting anonymous sign-in.");
                        try {
                            // Always attempt anonymous sign-in for public web apps.
                            // The __initial_auth_token is specific to the Canvas environment.
                            await signInAnonymously(auth);
                        } catch (error) {
                            console.error("Firebase authentication failed:", error);
                            showMessageBox("Failed to connect to game server. Please try again later.");
                        }
                    }
                });
            } else {
                console.error("Firebase config not found or is still placeholder. Multiplayer features disabled.");
                document.getElementById('currentUserId').textContent = 'Local Mode (Firebase Not Configured)';
                document.getElementById('joinGameBtn').disabled = true;
                document.getElementById('createGameBtn').disabled = true;
                findMatchBtn.disabled = true; // Disable find match in local mode
                lobbyMessage.textContent = "Firebase is not configured. Please replace 'YOUR_API_KEY', 'YOUR_AUTH_DOMAIN', etc., with your actual Firebase project credentials in the script.";
                lobbyMessage.classList.add('text-red-400');
            }

            updateButtonStates(); // Ensure buttons are correctly disabled/enabled
        };

    </script>
</body>
</html>
